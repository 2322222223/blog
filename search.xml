<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flutter构建APK-IPA配置</title>
      <link href="/blog/2023/09/16/Flutter%E6%9E%84%E5%BB%BAAPK-IPA%E9%85%8D%E7%BD%AE/"/>
      <url>/blog/2023/09/16/Flutter%E6%9E%84%E5%BB%BAAPK-IPA%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter编译安卓-iOS命令"><a href="#Flutter编译安卓-iOS命令" class="headerlink" title="Flutter编译安卓&#x2F;iOS命令"></a>Flutter编译安卓&#x2F;iOS命令</h1><h2 id="一、Flutter打包编译命令"><a href="#一、Flutter打包编译命令" class="headerlink" title="一、Flutter打包编译命令"></a>一、Flutter打包编译命令</h2><p>Flutter 提供了简单而灵活的编译命令，能够编译安卓 APK、安卓 AppBundle 和 iOS IPA。以下是详细的编译命令和示例。</p><h3 id="1、编译安卓-APK"><a href="#1、编译安卓-APK" class="headerlink" title="1、编译安卓 APK"></a>1、编译安卓 APK</h3><p>使用 <code>flutter build apk</code> 命令可以编译安卓 APK 文件。以下是一个编译 debug 版本的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh</span><br><span class="line">复制代码</span><br><span class="line">flutter build apk --debug --flavor beta --build-number=1 --build-name=0.1.0</span><br></pre></td></tr></table></figure><h3 id="2、编译安卓-AppBundle"><a href="#2、编译安卓-AppBundle" class="headerlink" title="2、编译安卓 AppBundle"></a>2、编译安卓 AppBundle</h3><p>安卓 AppBundle 是一种新的应用发布格式，它能够更好地优化应用的大小和性能。使用 <code>flutter build appbundle</code> 命令可以编译安卓 AppBundle：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh</span><br><span class="line">复制代码</span><br><span class="line">flutter build appbundle --release --flavor production --build-number=1 --build-name=1.0.0</span><br></pre></td></tr></table></figure><h3 id="3、编译iOS-IPA"><a href="#3、编译iOS-IPA" class="headerlink" title="3、编译iOS IPA"></a>3、编译iOS IPA</h3><p>编译 iOS 应用需要在 macOS 上进行，并且需要配置 Xcode。使用 <code>flutter build ios</code> 命令可以编译 iOS 应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh</span><br><span class="line">复制代码</span><br><span class="line">flutter build ios --release --no-codesign</span><br></pre></td></tr></table></figure><h2 id="二、Flutter打包编译命令配合Jenkins使用"><a href="#二、Flutter打包编译命令配合Jenkins使用" class="headerlink" title="二、Flutter打包编译命令配合Jenkins使用"></a>二、Flutter打包编译命令配合Jenkins使用</h2><p>在实际开发中，常常需要将 Flutter 编译命令集成到 CI&#x2F;CD 流程中，例如 Jenkins。以下是一个简单的 Jenkins Pipeline 配置示例，用于自动化编译 Flutter 应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">groovy复制代码pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&#x27;Checkout&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                git &#x27;https://github.com/your-repository.git&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Build APK&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;flutter clean&#x27;</span><br><span class="line">                sh &#x27;flutter pub get&#x27;</span><br><span class="line">                sh &#x27;flutter build apk --release&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Build AppBundle&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;flutter clean&#x27;</span><br><span class="line">                sh &#x27;flutter pub get&#x27;</span><br><span class="line">                sh &#x27;flutter build appbundle --release&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(&#x27;Build iOS&#x27;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh &#x27;flutter clean&#x27;</span><br><span class="line">                sh &#x27;flutter pub get&#x27;</span><br><span class="line">                sh &#x27;flutter build ios --release --no-codesign&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、编译问题处理"><a href="#三、编译问题处理" class="headerlink" title="三、编译问题处理"></a>三、编译问题处理</h2><h3 id="1、处理build-apk时安卓应用版本versionCode自动加1000问题"><a href="#1、处理build-apk时安卓应用版本versionCode自动加1000问题" class="headerlink" title="1、处理build apk时安卓应用版本versionCode自动加1000问题"></a>1、处理build apk时安卓应用版本versionCode自动加1000问题</h3><p>在编译过程中，可能会遇到版本号自动增加的问题。以下是一个具体的案例及其解决方案。</p><h4 id="1、编译的结果"><a href="#1、编译的结果" class="headerlink" title="1、编译的结果"></a>1、编译的结果</h4><p>编译命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh</span><br><span class="line">复制代码</span><br><span class="line">flutter build apk --debug --flavor beta --build-number=1 --build-name=0.1.0</span><br></pre></td></tr></table></figure><p>编译出来的结果发现 versionCode 加了 1000。</p><h4 id="2、原因分析"><a href="#2、原因分析" class="headerlink" title="2、原因分析"></a>2、原因分析</h4><p>经过分析 Flutter 编译脚本 <code>android/app/build.gradle</code>，发现引入了下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gradle复制代码if (project.android.defaultConfig.versionCode == null) &#123;</span><br><span class="line">    project.android.defaultConfig.versionCode = project.flutter.versionCode + 1000</span><br><span class="line">&#125; else if (project.android.defaultConfig.versionCode == 1) &#123;</span><br><span class="line">    // Do not increment the version code if the default version code is 1</span><br><span class="line">    // This is the default value and it will be incremented by flutter as needed.</span><br><span class="line">&#125; else if (project.android.defaultConfig.versionCode &gt; project.flutter.versionCode) &#123;</span><br><span class="line">    project.logger.error(&quot;Warning! The &#x27;android.defaultConfig.versionCode&#x27; property is higher than &quot;</span><br><span class="line">        + &quot;&#x27;flutter.versionCode&#x27;. This is not recommended and might cause problems. See &quot;</span><br><span class="line">        + &quot;https://github.com/flutter/flutter/issues/53919 for more details.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、处理方案"><a href="#3、处理方案" class="headerlink" title="3、处理方案"></a>3、处理方案</h4><p>在 <code>android/app/build.gradle</code> 文件中，<code>android</code> 层级下，添加如下内容以覆盖自动增加的 <code>versionCode</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gradle复制代码android &#123;</span><br><span class="line">    ...</span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            output.versionCodeOverride = variant.versionCode</span><br><span class="line">            println &quot;&gt; versionCode: $&#123;variant.versionCode&#125;, flutterVersionCode: $&#123;project.flutter.versionCode&#125;, versionCodeOverride: $&#123;output.versionCodeOverride&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置版本控制"><a href="#配置版本控制" class="headerlink" title="配置版本控制"></a>配置版本控制</h3><p>默认情况下，当 Gradle 生成多个 APK 时，每个 APK 都有相同的版本信息，该信息在模块级 <code>build.gradle</code> 文件中指定。由于 Google Play 商店不允许同一个应用的多个 APK 全都具有相同的版本信息，因此在上传到 Play 商店之前，需要确保每个 APK 都有自己唯一的 <code>versionCode</code>。</p><p>可以配置模块级 <code>build.gradle</code> 文件以替换每个 APK 的 <code>versionCode</code>。通过创建一种映射关系来配置了多 APK 构建的每种 ABI 和密度分配一个唯一的数值，可以将输出版本代码替换为一个将在 <code>defaultConfig</code> 或 <code>productFlavors</code> 代码块中定义的版本代码与分配给相应密度或 ABI 的数值组合在一起的值。</p><p>在以下示例中，<code>x86</code> ABI 的 APK 的 <code>versionCode</code> 将为 2004，<code>x86_64</code> ABI 的 APK 的版本代码将为 3004。如果以较大的增量（如 1000）分配版本代码，那么以后需要更新应用时，就可以分配唯一的版本代码。例如，如果 <code>defaultConfig.versionCode</code> 在后续更新中迭代到 5，那么 Gradle 为 <code>x86</code> APK 分配的 <code>versionCode</code> 将为 2005，为 <code>x86_64</code> APK 分配的版本代码将为 3005。</p><p><strong>提示</strong>：如果 build 包含一个通用 APK，为其分配的 <code>versionCode</code> 应低于为其他任何 APK 分配的版本代码。由于 Google Play 商店会安装既与目标设备兼容又具有最高 <code>versionCode</code> 的应用版本，因此为通用 APK 分配一个较低的 <code>versionCode</code> 可以确保 Google Play 商店在回退到通用 APK 之前先尝试安装某个 APK。以下示例代码的处理方式是不替换通用 APK 的默认 <code>versionCode</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gradle复制代码android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        versionCode 4</span><br><span class="line">    &#125;</span><br><span class="line">    splits &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Map for the version code that gives each ABI a value.</span><br><span class="line">ext.abiCodes = [&#x27;armeabi-v7a&#x27;: 1, x86: 2, x86_64: 3]</span><br></pre></td></tr></table></figure><p>如需查看备用版本代码方案的更多示例，请参阅<a href="https://developer.android.com/google/play/publishing/multiple-apks?hl=zh-cn#VersionCodes">分配版本代码</a>。</p><p>总结：Flutter 在打包的时候会通过以下代码来处理版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gradle复制代码if (project.android.defaultConfig.versionCode == null) &#123;</span><br><span class="line">    project.android.defaultConfig.versionCode = project.flutter.versionCode + 1000</span><br><span class="line">&#125; else if (project.android.defaultConfig.versionCode == 1) &#123;</span><br><span class="line">    // Do not increment the version code if the default version code is 1</span><br><span class="line">    // This is the default value and it will be incremented by flutter as needed.</span><br><span class="line">&#125; else if (project.android.defaultConfig.versionCode &gt; project.flutter.versionCode) &#123;</span><br><span class="line">    project.logger.error(&quot;Warning! The &#x27;android.defaultConfig.versionCode&#x27; property is higher than &quot;</span><br><span class="line">        + &quot;&#x27;flutter.versionCode&#x27;. This is not recommended and might cause problems. See &quot;</span><br><span class="line">        + &quot;https://github.com/flutter/flutter/issues/53919 for more details.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>android.defaultConfig.versionCode</code> 未设置，那么 Flutter 会使用 <code>flutter.versionCode + 1000</code> 作为版本代码。 如果 <code>android.defaultConfig.versionCode</code> 设置为 1（默认值），则 Flutter 会按需自动增加它。 如果 <code>android.defaultConfig.versionCode</code> 大于 <code>flutter.versionCode</code>，则会输出一个警告。</p><p>因此，如果当前是 arm32 位的包，会自动添加 1000 + version:1.0.0+1，即 1001 的版本号；如果是 arm64 位的包，会自动添加 2000 + version:1.0.0+1，即 2001 的版本号。如果打通用的包，最好要少于 arm32 最低版本号 1001。</p><hr><p>以上就是关于Flutter打包构建Android和IOS的包内容。希望本文对你有所帮助，如果有任何疑问或建议，欢迎在评论区交流讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> APK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter性能优化</title>
      <link href="/blog/2023/06/21/Flutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2023/06/21/Flutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>尽管 Flutter 本身性能已经非常出色，但在实际应用中仍然存在优化的空间。本文将详细介绍一些 Flutter 性能优化的示例和技巧，以帮助开发者提升应用的运行效率和用户体验。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E5%87%8F%E5%B0%91-rebuild">减少 Rebuild</a></li><li><a href="#%E4%BD%BF%E7%94%A8-const-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">使用 const 构造函数</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6">使用高效的列表控件</a></li><li><a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%B8%83%E5%B1%80%E8%AE%A1%E7%AE%97">避免不必要的布局计算</a></li><li><a href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86-io-%E6%93%8D%E4%BD%9C">异步处理 I&#x2F;O 操作</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%BE%E5%BC%8F%E5%8A%A8%E7%94%BB">使用显式动画</a></li><li><a href="#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">图片优化</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%BC%98%E5%8C%96">网络请求优化</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">使用性能分析工具</a></li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在开发 Flutter 应用时，性能优化主要集中在以下几个方面：</p><ul><li><strong>UI 渲染效率</strong>：避免不必要的 UI 重建和布局计算。</li><li><strong>图片处理</strong>：优化图片加载和显示。</li><li><strong>网络请求</strong>：减少网络请求的频率和大小。</li><li><strong>动画</strong>：使用高效的动画控件和方法。</li><li><strong>异步操作</strong>：确保 I&#x2F;O 操作异步执行，不阻塞主线程。</li></ul><p>接下来，我们将详细讨论这些方面的优化方法和示例。</p><h2 id="减少-Rebuild"><a href="#减少-Rebuild" class="headerlink" title="减少 Rebuild"></a>减少 Rebuild</h2><p>在 Flutter 中，Widget 是不可变的，每次状态变化都会导致 Widget 重建。如果不加以控制，频繁的重建会导致性能问题。我们可以通过以下几种方式减少不必要的 rebuild：</p><h3 id="使用-const-构造函数"><a href="#使用-const-构造函数" class="headerlink" title="使用 const 构造函数"></a>使用 <code>const</code> 构造函数</h3><p>使用 <code>const</code> 构造函数创建的 Widget 是不可变的，只会在初始化时构建一次。这样可以避免不必要的重建，提高性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">class MyWidget extends StatelessWidget &#123;</span><br><span class="line">  const MyWidget(&#123;Key? key&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return const Text(&#x27;Hello, World!&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-AutomaticKeepAliveClientMixin"><a href="#使用-AutomaticKeepAliveClientMixin" class="headerlink" title="使用 AutomaticKeepAliveClientMixin"></a>使用 <code>AutomaticKeepAliveClientMixin</code></h3><p>在长列表中，滚动时会销毁不在屏幕上的 Widget。我们可以使用 <code>AutomaticKeepAliveClientMixin</code> 来保留这些 Widget，从而减少重建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">class MyListItem extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _MyListItemState createState() =&gt; _MyListItemState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyListItemState extends State&lt;MyListItem&gt; with AutomaticKeepAliveClientMixin &#123;</span><br><span class="line">  @override</span><br><span class="line">  bool get wantKeepAlive =&gt; true;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    super.build(context);</span><br><span class="line">    return ListTile(title: Text(&#x27;List Item&#x27;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用高效的列表控件"><a href="#使用高效的列表控件" class="headerlink" title="使用高效的列表控件"></a>使用高效的列表控件</h2><p>在处理长列表时，使用高效的列表控件可以显著提高性能。<code>ListView.builder</code> 和 <code>GridView.builder</code> 是处理长列表的最佳选择，因为它们只会构建当前屏幕上可见的项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">ListView.builder(</span><br><span class="line">  itemCount: 1000,</span><br><span class="line">  itemBuilder: (context, index) &#123;</span><br><span class="line">    return ListTile(</span><br><span class="line">      title: Text(&#x27;Item $index&#x27;),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="避免不必要的布局计算"><a href="#避免不必要的布局计算" class="headerlink" title="避免不必要的布局计算"></a>避免不必要的布局计算</h2><p>使用 <code>LayoutBuilder</code> 可以避免在布局过程中进行不必要的计算。<code>LayoutBuilder</code> 只有在其约束条件改变时才会重新构建其子 Widget。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">LayoutBuilder(</span><br><span class="line">  builder: (context, constraints) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      width: constraints.maxWidth / 2,</span><br><span class="line">      height: 50,</span><br><span class="line">      color: Colors.blue,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="异步处理-I-O-操作"><a href="#异步处理-I-O-操作" class="headerlink" title="异步处理 I&#x2F;O 操作"></a>异步处理 I&#x2F;O 操作</h2><p>将耗时的 I&#x2F;O 操作（如文件读取和网络请求）放在异步方法中执行，避免阻塞主线程，从而提高应用的响应速度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">Future&lt;void&gt; loadData() async &#123;</span><br><span class="line">  final data = await fetchDataFromNetwork();</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _data = data;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用显式动画"><a href="#使用显式动画" class="headerlink" title="使用显式动画"></a>使用显式动画</h2><p>Flutter 提供了多种动画控件，如 <code>AnimatedContainer</code>、<code>AnimatedOpacity</code> 等。这些控件在状态变化时会自动执行动画，简化了动画的实现过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">AnimatedContainer(</span><br><span class="line">  duration: Duration(seconds: 1),</span><br><span class="line">  width: _isExpanded ? 200 : 100,</span><br><span class="line">  height: 50,</span><br><span class="line">  color: _isExpanded ? Colors.blue : Colors.red,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="使用合适的图片格式"><a href="#使用合适的图片格式" class="headerlink" title="使用合适的图片格式"></a>使用合适的图片格式</h3><p>根据图片内容选择合适的格式。例如，矢量图使用 SVG 格式，照片使用 JPEG 格式，图标使用 PNG 格式。</p><h3 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h3><p>使用 <code>cached_network_image</code> 包可以轻松实现图片缓存，减少网络请求次数，提高图片加载速度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">CachedNetworkImage(</span><br><span class="line">  imageUrl: &quot;https://example.com/image.jpg&quot;,</span><br><span class="line">  placeholder: (context, url) =&gt; CircularProgressIndicator(),</span><br><span class="line">  errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="网络请求优化"><a href="#网络请求优化" class="headerlink" title="网络请求优化"></a>网络请求优化</h2><h3 id="批量请求"><a href="#批量请求" class="headerlink" title="批量请求"></a>批量请求</h3><p>将多个网络请求合并为一个请求，减少请求次数和网络开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">Future&lt;void&gt; fetchMultipleData() async &#123;</span><br><span class="line">  final responses = await Future.wait([</span><br><span class="line">    http.get(Uri.parse(&#x27;https://example.com/data1&#x27;)),</span><br><span class="line">    http.get(Uri.parse(&#x27;https://example.com/data2&#x27;)),</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  // 处理响应数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用合适的数据格式"><a href="#使用合适的数据格式" class="headerlink" title="使用合适的数据格式"></a>使用合适的数据格式</h3><p>根据需求选择合适的数据格式。例如，文本数据使用 JSON 格式，二进制数据使用 Protobuf 格式。</p><h2 id="使用性能分析工具"><a href="#使用性能分析工具" class="headerlink" title="使用性能分析工具"></a>使用性能分析工具</h2><p>Flutter 提供了多种性能分析工具，如 Flutter DevTools、Dart DevTools 等。这些工具可以帮助开发者检测和解决性能问题。</p><h3 id="Flutter-DevTools"><a href="#Flutter-DevTools" class="headerlink" title="Flutter DevTools"></a>Flutter DevTools</h3><p>Flutter DevTools 提供了详细的性能分析和调试功能，可以用来检测 UI 渲染性能、内存使用情况等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行应用时，使用以下命令启动 DevTools：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh</span><br><span class="line">复制代码</span><br><span class="line">flutter pub global activate devtools</span><br><span class="line">flutter pub global run devtools</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上是一些基础的优化方案，可以提高 Flutter 应用的性能。在实际开发中，应结合具体应用场景，选择适合的优化方法，不断提升应用的运行效率和用户体验。</p><p>希望本文对你在 Flutter 性能优化方面有所帮助。如果有任何疑问或建议，欢迎在评论区交流讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Actions私有仓库部署踩坑记</title>
      <link href="/blog/2023/06/01/Github-Actions%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
      <url>/blog/2023/06/01/Github-Actions%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><em>在使用 GitHub Actions 自动化部署 Hexo 博客的过程中，因为我是使用的私有仓库来存储blog源码,更新后需要将public自动提交到公共仓库中.</em></p><ol><li><h5 id="部署密钥和令牌问题"><a href="#部署密钥和令牌问题" class="headerlink" title="部署密钥和令牌问题:"></a>部署密钥和令牌问题:</h5><ul><li>GitHub Actions 默认的 GITHUB_TOKEN 不支持推送到外部仓库。这意味着当我们尝试将生成的站点文件从一个仓库推送到另一个仓库时，GITHUB_TOKEN 无法使用,(我这里是使用<code>peaceiris/actions-gh-pages@v3</code>来进行部署)。 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">        <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure> 接下来推送代码,部署过程中报错然后查看Workflow Deploy: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Action failed with <span class="string">&quot;The generated GITHUB_TOKEN (github_tokendoes not support to push to an external repository.</span></span><br><span class="line"><span class="string">Use deploy_key or personal_token.</span></span><br></pre></td></tr></table></figure> 原来GITHUB_TOKEN是不支持推送到外部仓库,只能在当前的仓库去执行操作,比如:如推送文件、修改 Issues 等。</li></ul><p> 那就去创建一个,接着:</p><ul><li><code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code> -&gt; <code>Generate new token</code> -&gt; <code>勾选repo</code> -&gt; <code>Generate</code></li></ul><p> 然后把创建的PAT添加到Secrets:</p><ul><li><code>仓库页面</code> -&gt; <code>Settings</code> -&gt; <code>Secrets and variables</code> -&gt; <code>Actions</code> -&gt; <code>New repository secret</code> -&gt; <code>填写Name和生成的PAT</code></li></ul><p> OK,把这个名称填写到:</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRETS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p> 注: secrets.NAME不能使用GITHUB_开头。</p><p> 下面介绍一下支持的Tokens:</p><table><thead><tr><th>Token</th><th>Private repo</th><th>Public repo</th><th>Protocol</th><th>Setup</th></tr></thead><tbody><tr><td>github_token</td><td>✅️</td><td>✅️</td><td>HTTPS</td><td>Unnecessary</td></tr><tr><td>deploy_key</td><td>✅️</td><td>✅️</td><td>SSH</td><td>Necessary</td></tr><tr><td>personal_token</td><td>✅️</td><td>✅️</td><td>HTTPS</td><td>Necessary</td></tr></tbody></table><p> 实际上GITHUB_TOKEN是可以访问部署GitHub Pages的,但由于我们第一步部署需要选择或者创建GitHub Pages分支,通常为:<code>gh-pages</code>,第一次操作通常没有添加write权限,所以会报错:<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/git push origin gh-pages</span><br><span class="line">remote: Write access to repository not granted.</span><br><span class="line">fatal: unable to access &#x27;https://github.com/username/repository.git/&#x27;: The requested URL returned error: 403</span><br><span class="line">Error: Action failed with &quot;The process &#x27;/usr/bin/git&#x27; failed with exit code 128&quot;</span><br></pre></td></tr></table></figure></p></li><li><h5 id="SSH-私钥deploy-key限制"><a href="#SSH-私钥deploy-key限制" class="headerlink" title="SSH 私钥deploy_key限制:"></a>SSH 私钥deploy_key限制:</h5> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setup auth token</span><br><span class="line">Error: Action failed with &quot;not found deploy key or tokens&quot;</span><br></pre></td></tr></table></figure><ul><li>Secret中Aciton应该的对应的<code>personal_token</code>,主要作用是用于提交git-commit相关的一些操作。</li><li><code>deploy_key</code>应该通过Deploy keys应该是通过SSH生成的公钥。</li><li>同样SSH的私钥应该是在<code>Dependabot</code>中添加的,这样才能对应的上来。</li></ul><p> 具体的操作:</p><ol><li><p>生成部署的秘钥:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f gh-pages-deploy -N &quot;&quot; </span><br></pre></td></tr></table></figure><p> 生成两个文件:<code>gh-pages-deploy.pub</code>公钥,<code>gh-pages-deploy</code> 私钥,<br> 查看并复制</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat gh-pages-deploy</span><br><span class="line">cat gh-pages-deploy.pub</span><br></pre></td></tr></table></figure></li><li><p>然后转到Deploy Key添加公钥，勾选允许写入访问</p></li><li><p>最后转到<code>仓库页面</code> -&gt; <code>Settings</code> -&gt; <code>Secrets and variables</code> -&gt; <code>Actions</code> -&gt; <code>New repository secret</code> 添加私钥</p></li></ol><p> 最后:<br> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRETS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLIC_DEPLOY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><p>GitHub Actions 是一个强大的工具，可以帮助自动化 Hexo 博客的部署过程。然而，正确配置是成功部署的关键。通过以上讨论的问题和解决方案，我们可以更有效地管理和解决在自动化部署过程中可能遇到的挑战。</p><hr><p>这篇文章概述了与 GitHub Actions 相关的一些常见问题以及如何解决这些问题，希望能帮助你更好地使用这个强大的自动化工具。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> Github Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/blog/2023/02/18/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2023/02/18/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ol><li>保存命令</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker save -o name.tar image-name</span><br><span class="line"></span><br><span class="line">#压缩镜像</span><br><span class="line">gzip name.tar</span><br></pre></td></tr></table></figure></blockquote><ol><li>保存并直接压缩</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save image-name |gzip&gt;name.tar.gz</span><br></pre></td></tr></table></figure></blockquote><ol><li>build</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build -t image-name:tag -f Dockerfile .</span><br><span class="line"></span><br><span class="line">#根据当前的cpu架构来构建</span><br><span class="line">#docker build -t 172.18.0.40:82/ai/kubeflow-dashboard-frontend-enterprise:2023.12.28-amd64 -f install/docker/dockerFrontend/Dockerfile .</span><br><span class="line"></span><br><span class="line">#指定平台构建 可以选择amd64或arm64或者打包两个</span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t image-name:tag -f Dockerfile .  --push</span><br></pre></td></tr></table></figure></blockquote><ol><li>推送</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push image-name</span><br></pre></td></tr></table></figure></blockquote><ol><li>运行</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br><span class="line"></span><br><span class="line">#docker run -d -p 80:80 --name webserver nginx</span><br><span class="line">#使用 -d 参数在后台运行容器。-p 80:80 将容器的80端口映射到主机的80端口。--name webserver 给容器命名为 webserver。nginx 是要运行的镜像名称</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">#列出所有本地存储的镜像</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看容器</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">#列出当前运行的容器。</span><br><span class="line">#不带参数默认只显示运行中的容器。-a 参数显示所有容器，包括未运行</span><br></pre></td></tr></table></figure></blockquote><ol><li>停止</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br><span class="line">#停止一个或多个运行中的容器 docker stop webserver</span><br><span class="line">#停止所有: </span><br><span class="line">#docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure></blockquote><ol><li>删除容器</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br><span class="line">#删除一个或多个容器 docker rm webserver / docker rm -f webserver</span><br><span class="line">#删除所有:</span><br><span class="line">#docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure></blockquote><ol><li>删除镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi</span><br><span class="line">#删除一个或多个镜像 docker rmi webserver</span><br><span class="line">#删除所有:</span><br><span class="line">#docker rmi $(docker ps -aq)</span><br></pre></td></tr></table></figure></blockquote><ol><li>进入容器执行命令</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec</span><br><span class="line">#进入容器可以执行命令 docker exec -it webserver bash</span><br><span class="line">#docker exec -it mysql mysql -uroot -p</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看容器或镜像的详细信息</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect</span><br><span class="line">#docker inspect webserver </span><br><span class="line">#webserver 是容器或镜像的名称或 ID</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看log</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line">#获取容器列出的日志</span><br><span class="line">#docker logs webserver</span><br></pre></td></tr></table></figure></blockquote><ol><li>其他:</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#启动容器</span><br><span class="line">docker start</span><br><span class="line"></span><br><span class="line">#暂停进程</span><br><span class="line">docker pause</span><br><span class="line"></span><br><span class="line">#恢复容器</span><br><span class="line">docker unpause</span><br><span class="line"></span><br><span class="line">#重启容器</span><br><span class="line">docker restart</span><br><span class="line"></span><br><span class="line">#杀掉运行中的容器</span><br><span class="line">docker kill</span><br><span class="line"></span><br><span class="line">#开启docker </span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#查看docker状态</span><br><span class="line">systemctl status docker </span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">systemctl stop docker </span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line">systemctl  restart docker</span><br><span class="line"></span><br><span class="line">#设置开启自启</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></blockquote><ol><li>打标签</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag</span><br><span class="line">#给本地镜像打标签</span><br><span class="line">#docker tag myimage:tag username/repository:tag</span><br></pre></td></tr></table></figure></blockquote><ol><li>加载本地镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load</span><br><span class="line">#加载tar本地镜像</span><br><span class="line">#docker load -i filename.tar</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看历史记录</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker history</span><br><span class="line">#查看镜像的历史记录</span><br><span class="line">#docker history myimage:tag</span><br></pre></td></tr></table></figure></blockquote><ol><li>从容器中拷贝</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp container-name file-name</span><br></pre></td></tr></table></figure></blockquote><p>19.导出容器 另存为文件</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export -o file-name.tar container-name/container-id</span><br></pre></td></tr></table></figure></blockquote><p>20.从文件导入镜像</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import file-name.tar container-name:tag</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/blog/2022/10/18/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2022/10/18/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="基础常用命令"><a href="#基础常用命令" class="headerlink" title="基础常用命令"></a>基础常用命令</h2><ul><li><p><code>某个命令 --h</code>，对这个命令进行解释</p></li><li><p><code>某个命令 --help</code>，解释这个命令(更详细)</p></li><li><p><code>man某个命令</code>，文档式解释这个命令(更更详细)(执行该命令后,还可以按&#x2F;+关键字进行查询结果的搜索)</p></li><li><p><code>Ctrl + c</code>，结束命令</p></li><li><p><code>history</code>，查看所有的历史命令</p></li><li><p><code>Ctrl + r</code>，进入历史命令的搜索功能模式</p></li><li><p><code>clear</code>，清除屏幕里面的所有命令</p></li><li><p><code>pwd</code>，显示当前目录路径（常用）</p></li><li><p><code>firefox&amp;</code>，最后后面的 <strong>&amp;</strong> 符号，表示使用后台方式打开 Firefox，然后显示该进程的 PID 值</p></li><li><p><code>jobs</code>，查看后台运行的程序列表</p></li><li><p><code>ifconfig</code>，查看内网 IP 等信息（常用）</p></li><li><p><code>curl ifconfig.me</code>，查看外网 IP 信息</p></li><li><p><code>curl ip.cn</code>，查看外网 IP 信息</p></li><li><pre><code>locate 搜索关键字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，快速搜索系统文件/文件夹（类似 Windows 上的 everything 索引式搜索）（常用）</span><br><span class="line"></span><br><span class="line">  - `updatedb`，配合上面的 locate，给 locate 的索引更新（locate 默认是一天更新一次索引）（常用）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  date</span><br></pre></td></tr></table></figure>，查看系统时间（常用）- `date -s20080103`，设置日期（常用）- `date -s18:24`，设置时间，如果要同时更改 BIOS 时间，再执行 `hwclock --systohc`（常用）</code></pre></li><li><p><code>cal</code>，在终端中查看日历，肯定没有农历显示的</p></li><li><p><code>uptime</code>，查看系统已经运行了多久，当前有几个用户等信息（常用）</p></li><li><p><code>cat 文件路名</code>，显示文件内容（属于打印语句）</p></li><li><p><code>cat -n 文件名</code>，显示文件，并每一行内容都编号</p></li><li><p><code>more 文件名</code>，用分页的方式查看文件内容（按 space 翻下一页，按 <em>Ctrl + B</em> 返回上页）</p></li><li><pre><code>less<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  文件名，用分页的方式查看文件内容（带上下翻页）</span><br><span class="line"></span><br><span class="line">  - 按 **j** 向下移动，按 **k** 向上移动</span><br><span class="line">  - 按 **/** 后，输入要查找的字符串内容，可以对文件进行向下查询，如果存在多个结果可以按 **n** 调到下一个结果出</span><br><span class="line">  - 按 **？** 后，输入要查找的字符串内容，可以对文件进行向上查询，如果存在多个结果可以按 **n** 调到下一个结果出</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  shutdown</span><br></pre></td></tr></table></figure>- `shutdown -hnow`，立即关机- `shutdown -h+10`，10 分钟后关机- `shutdown -h23:30`，23:30 关机- `shutdown -rnew`，立即重启</code></pre></li><li><p><code>poweroff</code>，立即关机（常用）</p></li><li><p><code>reboot</code>，立即重启（常用）</p></li><li><pre><code>zip mytest.zip /opt/test/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，把 /opt 目录下的 test/ 目录进行压缩，压缩成一个名叫 mytest 的 zip 文件</span><br><span class="line"></span><br><span class="line">  - `unzip mytest.zip`，对 mytest.zip 这个文件进行解压，解压到当前所在目录</span><br><span class="line">  - `unzip mytest.zip -d /opt/setups/`，对 mytest.zip 这个文件进行解压，解压到 /opt/setups/ 目录下</span><br><span class="line"></span><br><span class="line">- `tar -cvf mytest.tar mytest/`，对 mytest/ 目录进行归档处理（归档和压缩不一样）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tar -xvf mytest.tar</span><br></pre></td></tr></table></figure>，释放 mytest.tar 这个归档文件，释放到当前目录- `tar -xvf mytest.tar -C /opt/setups/`，释放 mytest.tar 这个归档文件，释放到 /opt/setups/ 目录下</code></pre></li><li><p><code>last</code>，显示最近登录的帐户及时间</p></li><li><p><code>lastlog</code>，显示系统所有用户各自在最近登录的记录，如果没有登录过的用户会显示 <strong>从未登陆过</strong></p></li><li><pre><code>ls<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">，列出当前目录下的所有没有隐藏的文件 / 文件夹。</span><br><span class="line"></span><br><span class="line">- `ls -a`，列出包括以.号开头的隐藏文件 / 文件夹（也就是所有文件）</span><br><span class="line">- `ls -R`，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，不显示隐藏的文件）</span><br><span class="line">- `ls -a -R`，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，显示隐藏的文件）</span><br><span class="line">- `ls -al`，列出目录下所有文件（包含隐藏）的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息）</span><br><span class="line">- `ls -ld 目录名`，显示该目录的基本信息</span><br><span class="line">- `ls -t`，依照文件最后修改时间的顺序列出文件名。</span><br><span class="line">- `ls -F`，列出当前目录下的文件名及其类型。以 **/** 结尾表示为目录名，以 ***** 结尾表示为可执行文件，以 **@** 结尾表示为符号连接</span><br><span class="line">- `ls -lg`，同上，并显示出文件的所有者工作组名。</span><br><span class="line">- `ls -lh`，查看文件夹类文件详细信息，文件大小，文件修改时间</span><br><span class="line">- `ls /opt | head -5`，显示 opt 目录下前 5 条记录</span><br><span class="line">- `ls -l | grep &#x27;.jar&#x27;`，查找当前目录下所有 jar 文件</span><br><span class="line">- `ls -l /opt |grep &quot;^-&quot;|wc -l`，统计 opt 目录下文件的个数，不会递归统计</span><br><span class="line">- `ls -lR /opt |grep &quot;^-&quot;|wc -l`，统计 opt 目录下文件的个数，会递归统计</span><br><span class="line">- `ls -l /opt |grep &quot;^d&quot;|wc -l`，统计 opt 目录下目录的个数，不会递归统计</span><br><span class="line">- `ls -lR /opt |grep &quot;^d&quot;|wc -l`，统计 opt 目录下目录的个数，会递归统计</span><br><span class="line">- `ls -lR /opt |grep &quot;js&quot;|wc -l`，统计 opt 目录下 js 文件的个数，会递归统计</span><br><span class="line">- `ls -l`，列出目录下所有文件的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息，不显示隐藏文件）。显示出来的效果如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>-rwxr-xr-x. 1 root root 4096 3月 26 10:57，其中最前面的 - 表示这是一个普通文件lrwxrwxrwx. 1 root root 4096 3月 26 10:57，其中最前面的 l 表示这是一个链接文件，类似 Windows 的快捷方式drwxr-xr-x. 5 root root 4096 3月 26 10:57，其中最前面的 d 表示这是一个目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  cd</span><br></pre></td></tr></table></figure>，目录切换- `cd ..`，改变目录位置至当前目录的父目录(上级目录)。- `cd ~`，改变目录位置至用户登录时的工作目录。- `cd 回车`，回到家目录- `cd -`，上一个工作目录- `cd dir1/`，改变目录位置至 dir1 目录下。- `cd ~user`，改变目录位置至用户的工作目录。- `cd ../user`，改变目录位置至相对路径user的目录下。- `cd /../..`，改变目录位置至绝对路径的目录位置下。</code></pre></li><li><pre><code>cp 源文件 目标文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，复制文件</span><br><span class="line"></span><br><span class="line">  - `cp -r 源文件夹 目标文件夹`，复制文件夹</span><br><span class="line">  - `cp -r -v 源文件夹 目标文件夹`，复制文件夹(显示详细信息，一般用于文件夹很大，需要查看复制进度的时候)</span><br><span class="line">  - `cp /usr/share/easy-rsa/2.0/keys/&#123;ca.crt,server.&#123;crt,key&#125;,dh2048.pem,ta.key&#125; /etc/openvpn/keys/`，复制同目录下花括号中的文件</span><br><span class="line"></span><br><span class="line">- `tar cpf - . | tar xpf - -C /opt`，复制当前所有文件到 /opt 目录下，一般如果文件夹文件多的情况下用这个更好，用 cp 比较容易出问题</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  mv 文件 目标文件夹</span><br></pre></td></tr></table></figure>，移动文件到目标文件夹- `mv 文件`，不指定目录重命名后的名字，用来重命名文件</code></pre></li><li><p><code>touch 文件名</code>，创建一个空白文件&#x2F;更新已有文件的时间(后者少用)</p></li><li><p><code>mkdir 文件夹名</code>，创建文件夹</p></li><li><p><code>mkdir -p /opt/setups/nginx/conf/</code>，创建一个名为 conf 文件夹，如果它的上级目录 nginx 没有也会跟着一起生成，如果有则跳过</p></li><li><p><code>rmdir 文件夹名</code>，删除文件夹(只能删除文件夹里面是没有东西的文件夹)</p></li><li><pre><code>rm 文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，删除文件</span><br><span class="line"></span><br><span class="line">  - `rm -r 文件夹`，删除文件夹</span><br><span class="line">  - `rm -r -i 文件夹`，在删除文件夹里的文件会提示(要的话,在提示后面输入yes)</span><br><span class="line">  - `rm -r -f 文件夹`，强制删除</span><br><span class="line">  - `rm -r -f 文件夹1/ 文件夹2/ 文件夹3/`删除多个</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  find</span><br></pre></td></tr></table></figure>，高级查找- `find . -name *lin*`，其中 . 代表在当前目录找，-name 表示匹配文件名 / 文件夹名，*lin* 用通配符搜索含有lin的文件或是文件夹- `find . -iname *lin*`，其中 . 代表在当前目录找，-iname 表示匹配文件名 / 文件夹名（忽略大小写差异），*lin* 用通配符搜索含有lin的文件或是文件夹- `find / -name *.conf`，其中 / 代表根目录查找，*.conf代表搜索后缀会.conf的文件- `find /opt -name .oh-my-zsh`，其中 /opt 代表目录名，.oh-my-zsh 代表搜索的是隐藏文件 / 文件夹名字为 oh-my-zsh 的- `find /opt -type f -iname .oh-my-zsh`，其中 /opt 代表目录名，-type f 代表只找文件，.oh-my-zsh 代表搜索的是隐藏文件名字为 oh-my-zsh 的- `find /opt -type d -iname .oh-my-zsh`，其中 /opt 代表目录名，-type d 代表只找目录，.oh-my-zsh 代表搜索的是隐藏文件夹名字为 oh-my-zsh 的- `find . -name &quot;lin*&quot; -exec ls -l &#123;&#125; \;`，当前目录搜索lin开头的文件，然后用其搜索后的结果集，再执行ls -l的命令（这个命令可变，其他命令也可以），其中 -exec 和 &#123;&#125; ; 都是固定格式- `find /opt -type f -size +800M  -print0 | xargs -0 du -h | sort -nr`，找出 /opt 目录下大于 800 M 的文件- `find / -name &quot;*tower*&quot; -exec rm &#123;&#125; \;`，找到文件并删除- `find / -name &quot;*tower*&quot; -exec mv &#123;&#125; /opt \;`，找到文件并移到 opt 目录- `find . -name &quot;*&quot; |xargs grep &quot;youmeek&quot;`，递归查找当前文件夹下所有文件内容中包含 youmeek 的文件- `find . -size 0 | xargs rm -f &amp;`，删除当前目录下文件大小为0的文件- `du -hm --max-depth=2 | sort -nr | head -12`，找出系统中占用容量最大的前 12 个目录</code></pre></li><li><p><code>cat /etc/resolv.conf</code>，查看 DNS 设置</p></li><li><p><code>netstat -tlunp</code>，查看当前运行的服务，同时可以查看到：运行的程序已使用端口情况</p></li><li><p><code>env</code>，查看所有系统变量</p></li><li><p><code>export</code>，查看所有系统变量</p></li><li><pre><code>echo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - `echo $JAVA_HOME`，查看指定系统变量的值，这里查看的是自己配置的 JAVA_HOME。</span><br><span class="line">  - `echo &quot;字符串内容&quot;`，输出 &quot;字符串内容&quot;</span><br><span class="line">  - `echo &gt; aa.txt`，清空 aa.txt 文件内容（类似的还有：`: &gt; aa.txt`，其中 : 是一个占位符, 不产生任何输出）</span><br><span class="line"></span><br><span class="line">- `unset $JAVA_HOME`，删除指定的环境变量</span><br><span class="line"></span><br><span class="line">- `ln -s /opt/data /opt/logs/data`，表示给 /opt/logs 目录下创建一个名为 data 的软链接，该软链接指向到 /opt/data</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  grep</span><br></pre></td></tr></table></figure>- `shell grep -H &#39;安装&#39; *.sh`，查找当前目录下所有 sh 类型文件中，文件内容包含 `安装` 的当前行内容- `grep &#39;test&#39; java*`，显示当前目录下所有以 java 开头的文件中包含 test 的行- `grep &#39;test&#39; spring.ini docker.sh`，显示当前目录下 spring.ini docker.sh 两个文件中匹配 test 的行</code></pre></li><li><pre><code>ps<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - `ps –ef|grep java`，查看当前系统中有关 java 的所有进程</span><br><span class="line">  - `ps -ef|grep --color java`，高亮显示当前系统中有关 java 的所有进程</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  kill</span><br></pre></td></tr></table></figure>- `kill 1234`，结束 pid 为 1234 的进程- `kill -9 1234`，强制结束 pid 为 1234 的进程（慎重）- `killall java`，结束同一进程组内的所有为 java 进程- `ps -ef|grep hadoop|grep -v grep|cut -c 9-15|xargs kill -9`，结束包含关键字 hadoop 的所有进程</code></pre></li><li><pre><code>head<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - `head -n 10 spring.ini`，查看当前文件的前 10 行内容</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tail</span><br></pre></td></tr></table></figure>- `tail -n 10 spring.ini`，查看当前文件的后 10 行内容- `tail -200f 文件名`，查看文件被更新的新内容尾 200 行，如果文件还有在新增可以动态查看到（一般用于查看日记文件）</code></pre></li></ul><h2 id="用户、权限-相关命令"><a href="#用户、权限-相关命令" class="headerlink" title="用户、权限-相关命令"></a>用户、权限-相关命令</h2><ul><li><p>使用 pem 证书登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /opt/mykey.pem root@192.168.0.70</span><br></pre></td></tr></table></figure><ul><li>证书权限不能太大，不然无法使用：<code>chmod 600 mykey.pem</code></li></ul></li><li><p><code>hostname</code>，查看当前登陆用户全名</p></li><li><p><code>cat /etc/group</code>，查看所有组</p></li><li><p><code>cat /etc/passwd</code>，查看所有用户</p></li><li><p><code>groups youmeek</code>，查看 youmeek 用户属于哪个组</p></li><li><p><code>useradd youmeek -g judasn</code>，添加用户并绑定到 judasn 组下</p></li><li><pre><code>userdel -r youmeek<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，删除名字为 youmeek 的用户</span><br><span class="line"></span><br><span class="line">  - 参数：`-r`，表示删除用户的时候连同用户的家目录一起删除</span><br><span class="line"></span><br><span class="line">- 修改普通用户 youmeek 的权限跟 root 权限一样：</span><br><span class="line"></span><br><span class="line">  - 常用方法（原理是把该用户加到可以直接使用 sudo 的一个权限状态而已）：</span><br><span class="line"></span><br><span class="line">    - 编辑配置文件：`vim /etc/sudoers`</span><br><span class="line">    - 找到 98 行（预估），有一个：`root    ALL=(ALL)   ALL`，在这一行下面再增加一行，效果如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>   root    ALL=(ALL)   ALL   youmeek    ALL=(ALL)   ALL  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  - 另一种方法：</span><br><span class="line"></span><br><span class="line">    - 编辑系统用户的配置文件：`vim /etc/passwd`，找到 **root** 和 **youmeek** 各自开头的那一行，比如 root 是：`root:x:0:0:root:/root:/bin/zsh`，这个代表的含义为：*用户名:密码:UserId:GroupId:描述:家目录:登录使用的 shell*</span><br><span class="line">    - 通过这两行对比，我们可以直接修改 youmeek 所在行的 UserId 值 和 GroupId 值，都改为 0。</span><br><span class="line"></span><br><span class="line">- `groupadd judasn`，添加一个名为 judasn 的用户组</span><br><span class="line"></span><br><span class="line">- `groupdel judasn`，删除一个名为 judasn 的用户组（前提：先删除组下面的所有用户）</span><br><span class="line"></span><br><span class="line">- `usermod 用户名 -g 组名`，把用户修改到其他组下</span><br><span class="line"></span><br><span class="line">- `passwd youmeek`，修改 youmeek 用户的密码（前提：只有 root 用户才有修改其他用户的权限，其他用户只能修改自己的）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  chmod 777 文件名/目录</span><br></pre></td></tr></table></figure>，给指定文件增加最高权限，系统中的所有人都可以进行读写。- linux 的权限分为 rwx。r 代表：可读，w 代表：可写，x 代表：可执行- 这三个权限都可以转换成数值表示，r = 4，w = 2，x = 1，- = 0，所以总和是 7，也就是最大权限。第一个 7 是所属主（user）的权限，第二个 7 是所属组（group）的权限，最后一位 7 是非本群组用户（others）的权限。- `chmod -R 777 目录` 表示递归目录下的所有文件夹，都赋予 777 权限- `chown myUsername:myGroupName myFile` 表示修改文件所属用户、组- `chown -R myUsername:myGroupName myFolder` 表示递归修改指定目录下的所有文件权限</code></pre></li><li><pre><code>suchown -R &lt;username&gt; a/chgrp -R &lt;username&gt; a/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ：切换到 root 用户，终端目录还是原来的地方（常用）</span><br><span class="line"></span><br><span class="line">  - `su -`：切换到 root 用户，其中 **-** 号另起一个终端并切换账号</span><br><span class="line">  - `su 用户名`，切换指定用户帐号登陆，终端目录还是原来地方。</span><br><span class="line">  - `su - 用户名`，切换到指定用户帐号登陆，其中 **-** 号另起一个终端并切换账号</span><br><span class="line"></span><br><span class="line">- `exit`，注销当前用户（常用）</span><br><span class="line"></span><br><span class="line">- `sudo 某个命令`，使用管理员权限使用命令，使用 sudo 回车之后需要输入当前登录账号的密码。（常用）</span><br><span class="line"></span><br><span class="line">- `passwd`，修改当前用户密码（常用）</span><br><span class="line"></span><br><span class="line">- 添加临时账号，并指定用户根目录，并只有可读权限方法</span><br><span class="line"></span><br><span class="line">  - 添加账号并指定根目录（用户名 tempuser）：`useradd -d /data/logs -m tempuser`</span><br><span class="line">  - 设置密码：`passwd tempuser` 回车设置密码</span><br><span class="line">  - 删除用户（该用户必须退出 SSH 才能删除成功），也会同时删除组：`userdel tempuser`</span><br><span class="line"></span><br><span class="line">## 磁盘管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  df -h</span><br></pre></td></tr></table></figure>，自动以合适的磁盘容量单位查看磁盘大小和使用空间- `df -k`，以磁盘容量单位 K 为数值结果查看磁盘使用情况- `df -m`，以磁盘容量单位 M 为数值结果查看磁盘使用情况</code></pre></li><li><p><code>du -sh /opt</code>，查看 opt 这个文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）</p></li><li><p><code>du -sh ./*</code>，查看当前目录下所有文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）</p></li><li><p><code>du -sh /opt/setups/</code>，显示 &#x2F;opt&#x2F;setups&#x2F; 目录所占硬盘空间大小（s 表示 –summarize 仅显示总计，即当前目录的大小。h 表示 –human-readable 以 KB，MB，GB 为单位，提高信息的可读性）</p></li><li><pre><code>mount /dev/sdb5 /newDir/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，把分区 sdb5 挂载在根目录下的一个名为 newDir 的空目录下，需要注意的是：这个目录最好为空，不然已有的那些文件将看不到，除非卸载挂载。</span><br><span class="line"></span><br><span class="line">  - 挂载好之后，通过：`df -h`，查看挂载情况。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  umount /newDir/</span><br></pre></td></tr></table></figure>，卸载挂载，用目录名- 如果这样卸载不了可以使用：`umount -l /newDir/`</code></pre></li><li><p><code>umount /dev/sdb5</code>，卸载挂载，用分区名</p></li></ul><h2 id="wget-下载文件"><a href="#wget-下载文件" class="headerlink" title="wget 下载文件"></a>wget 下载文件</h2><ul><li>常规下载：<code>wget http://www.gitnavi.com/index.html</code></li><li>自动断点下载：<code>wget -c http://www.gitnavi.com/index.html</code></li><li>后台下载：<code>wget -b http://www.gitnavi.com/index.html</code></li><li>伪装代理名称下载：<code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.gitnavi.com/index.html</code></li><li>限速下载：<code>wget --limit-rate=300k http://www.gitnavi.com/index.html</code></li><li>批量下载：<code>wget -i /opt/download.txt</code>，一个下载地址一行</li><li>后台批量下载：<code>wget -b -c -i /opt/download.txt</code>，一个下载地址一行</li></ul><hr><h1 id="Linux-下常用压缩文件的解压、压缩"><a href="#Linux-下常用压缩文件的解压、压缩" class="headerlink" title="Linux 下常用压缩文件的解压、压缩"></a>Linux 下常用压缩文件的解压、压缩</h1><h2 id="常用压缩包–解压–令整理"><a href="#常用压缩包–解压–令整理" class="headerlink" title="常用压缩包–解压–令整理"></a>常用压缩包–解压–令整理</h2><ul><li><p>Linux 后缀为 <code>.war</code> 格式的文件（一般用在部署 Tomcat 项目的时候）</p></li><li><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -oq XXXXXX.war -d ROOT</span><br></pre></td></tr></table></figure><ul><li>如果没有 ROOT 目录会自动创建 ROOT 目录。</li></ul></li><li><p>Linux 后缀为 <code>.tar.gz</code> 格式的文件-解压</p></li><li><p>命令：<code>tar zxvf XXXXXX.tar.gz</code></p></li><li><p>Linux 后缀为 <code>.bz2</code> 格式的文件-解压</p></li><li><p>命令：<code>bzip2 -d XXXXXX.bz2</code></p></li><li><p>Linux 后缀为 <code>.tar.bz2</code> 格式的文件-解压</p></li><li><p>命令：<code>tar jxvf XXXXXX.tar.bz2</code></p></li><li><p>Linux 后缀为 <code>.tar</code> 格式的文件-解压</p></li><li><p>命令：<code>tar zxvf XXXXXX.tar</code></p></li><li><p>Linux 后缀为 <code>.gz</code> 格式的文件-解压</p></li><li><p>命令：<code>gunzip XXXXXX.gz</code></p></li><li><p>Linux 后缀为 <code>.zip</code> 格式的文件-解压</p></li><li><p>命令：<code>unzip XXXXXX.zip</code></p></li><li><p>命令：<code>unzip XXXXXX.zip -d /opt/</code>，解压到指定目录</p></li><li><p>Linux 后缀为 <code>.7z</code> 格式的文件-解压</p></li><li><p>命令：<code>7za x XXXXXX.7z</code></p></li><li><p>Linux 后缀为 <code>.tar.xz</code> 格式的文件-解压，解压出来是tar，再对tar进行解压</p></li><li><p>命令：<code>tar xf XXXXXX.tar.xz</code></p></li></ul><hr><h2 id="常用文件进行–压缩–命令整理"><a href="#常用文件进行–压缩–命令整理" class="headerlink" title="常用文件进行–压缩–命令整理"></a>常用文件进行–压缩–命令整理</h2><ul><li>Linux 压缩文件夹为后缀 <code>.war</code> 格式的文件（最好不要对根目录进行压缩，不然会多出一级目录）</li><li>命令：<code>jar -cvfM0 cas.war /opt/cas/META-INF /opt/cas/WEB-INF /opt/cas/index.jsp</code></li><li>或者命令：<code>cd 项目根目录 ; jar -cvfM0 cas.war ./*</code></li><li>Linux 压缩文件为后缀 <code>.tar</code> 格式的文件</li><li>命令：<code>tar -zcvf test11.tar test11</code></li><li>Linux 压缩文件为后缀 <code>.tar.gz</code> 格式的文件</li><li>命令：<code>tar -zcvf test11.tar.gz test11</code></li><li>Linux 压缩文件为后缀 <code>.bz2</code> 格式的文件</li><li>命令：<code>bzip2 -v test.txt</code></li><li>Linux 压缩文件为后缀 <code>.tar.bz2</code> 格式的文件</li><li>命令：<code>tar -jcvf test11.tar.gz test11</code></li><li>Linux 压缩文件为后缀 <code>.zip</code> 格式的文件</li><li>命令：<code>zip -r test1.zip /opt/test1/</code></li><li>Linux 压缩文件为后缀 <code>.7z</code> 格式的文件</li><li>命令：<code>7za a test1.7z /opt/test1/</code></li></ul><h2 id="分卷压缩"><a href="#分卷压缩" class="headerlink" title="分卷压缩"></a>分卷压缩</h2><ul><li>分卷压缩：<code>zip -s 100M myFile.zip --out newFile.zip</code></li><li>最终效果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newFile.z01</span><br><span class="line">newFile.z02</span><br><span class="line">newFile.z03</span><br><span class="line">newFile.z04</span><br><span class="line">newFile.zip</span><br></pre></td></tr></table></figure><h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><ul><li>7z<ul><li>7z 的安装：<ul><li>访问官网下载解压包：<a href="http://sourceforge.net/projects/p7zip/files/p7zip/">http://sourceforge.net/projects/p7zip/files/p7zip/</a></li><li>解压压缩包：<code>tar jxvf p7zip_15.14_src_all.tar.bz2</code></li><li>进入目录：<code>cd p7zip_15.14</code></li><li>执行安装：<code>sh install.sh</code></li></ul></li></ul></li><li>rar<ul><li>rar 的安装：<ul><li>下载：<code>wget http://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz</code></li><li>解压下载下来的压缩包：<code>tar zxvf rarlinux-3.8.0.tar.gz</code></li><li>进入解压后目录：<code>cd rar</code></li><li>编译：<code>make</code></li><li>安装：<code>make install</code></li></ul></li><li>rar 解压：<code>rar x 文件名.rar</code></li></ul></li></ul><hr><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。</p><p>注解</p><p>类似的工具有rsync；scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I&#x2F;O非常高，而scp基本不影响系统正常使用。</p><h2 id="18-1-命令格式："><a href="#18-1-命令格式：" class="headerlink" title="18.1. 命令格式："></a>18.1. 命令格式：</h2><p>scp [参数] [原路径] [目标路径]</p><h2 id="18-2-命令参数："><a href="#18-2-命令参数：" class="headerlink" title="18.2. 命令参数："></a>18.2. 命令参数：</h2><ul><li>-1 强制scp命令使用协议ssh1</li><li>-2 强制scp命令使用协议ssh2</li><li>-4 强制scp命令只使用IPv4寻址</li><li>-6 强制scp命令只使用IPv6寻址</li><li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p 留原文件的修改时间，访问时间和访问权限。</li><li>-q 不显示传输进度条。</li><li>-r 递归复制整个目录。</li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。</li><li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li><li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li></ul><h2 id="18-3-使用说明"><a href="#18-3-使用说明" class="headerlink" title="18.3. 使用说明"></a>18.3. 使用说明</h2><h3 id="从本地服务器复制到远程服务器"><a href="#从本地服务器复制到远程服务器" class="headerlink" title="从本地服务器复制到远程服务器"></a>从本地服务器复制到远程服务器</h3><p>复制文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$scp local_file remote_username@remote_ip:remote_folder</span><br><span class="line">$scp local_file remote_username@remote_ip:remote_file</span><br><span class="line">$scp local_file remote_ip:remote_folder</span><br><span class="line">$scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure><p>指定了用户名，命令执行后需要输入用户密码；如果不指定用户名，命令执行后需要输入用户名和密码；</p><p>复制目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$scp -r local_folder remote_username@remote_ip:remote_folder</span><br><span class="line">$scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure><p>第1个指定了用户名，命令执行后需要输入用户密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><p>注解</p><p>从远程复制到本地的scp命令与上面的命令一样，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p><h2 id="18-4-使用示例"><a href="#18-4-使用示例" class="headerlink" title="18.4. 使用示例"></a>18.4. 使用示例</h2><h3 id="实例1：从远处复制文件到本地目录"><a href="#实例1：从远处复制文件到本地目录" class="headerlink" title="实例1：从远处复制文件到本地目录"></a>实例1：从远处复制文件到本地目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/</span><br></pre></td></tr></table></figure><p>说明： 从10.6.159.147机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载demo.tar 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中</p><h3 id="实例2：从远处复制到本地"><a href="#实例2：从远处复制到本地" class="headerlink" title="实例2：从远处复制到本地"></a>实例2：从远处复制到本地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r root@10.6.159.147:/opt/soft/test /opt/soft/</span><br></pre></td></tr></table></figure><p>说明： 从10.6.159.147机器上的&#x2F;opt&#x2F;soft&#x2F;中下载test目录到本地的&#x2F;opt&#x2F;soft&#x2F;目录来。</p><h3 id="实例3：上传本地文件到远程机器指定目录"><a href="#实例3：上传本地文件到远程机器指定目录" class="headerlink" title="实例3：上传本地文件到远程机器指定目录"></a>实例3：上传本地文件到远程机器指定目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest</span><br></pre></td></tr></table></figure><p>说明： 复制本地opt&#x2F;soft&#x2F;目录下的文件demo.tar 到远程机器10.6.159.147的opt&#x2F;soft&#x2F;scptest目录</p><h3 id="实例4：上传本地目录到远程机器指定目录"><a href="#实例4：上传本地目录到远程机器指定目录" class="headerlink" title="实例4：上传本地目录到远程机器指定目录"></a>实例4：上传本地目录到远程机器指定目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r /opt/soft/test root@10.6.159.147:/opt/soft/scptest</span><br></pre></td></tr></table></figure><p>说明： 上传本地目录 &#x2F;opt&#x2F;soft&#x2F;test到远程机器10.6.159.147上&#x2F;opt&#x2F;soft&#x2F;scptest的目录中</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter开发过程中一些常见的问题和解决方案</title>
      <link href="/blog/2022/05/02/Flutter%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/blog/2022/05/02/Flutter%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在Flutter开发过程中，我们难免会遇到一些复杂和棘手的问题。这些深度问题往往需要更深入的理解和技术背景才能解决。本文将详细探讨一些Flutter开发中的深度疑难杂症，并提供相应的解决方案。</p><hr><h4 id="1-复杂状态管理"><a href="#1-复杂状态管理" class="headerlink" title="1. 复杂状态管理"></a>1. <strong>复杂状态管理</strong></h4><p><strong>问题描述：</strong> 在大型应用中，状态管理变得极为复杂，导致代码难以维护和调试。</p><p><strong>解决方案：</strong></p><ol><li><p><strong>引入Bloc（Business Logic Component）模式：</strong></p><p>Bloc是一个用于分离业务逻辑和UI层的模式。通过使用Bloc，我们可以将应用的状态管理集中到一个地方，使得代码更易于维护和测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:flutter_bloc/flutter_bloc.dart&#x27;;</span><br><span class="line"></span><br><span class="line">// 定义事件</span><br><span class="line">abstract class CounterEvent &#123;&#125;</span><br><span class="line">class Increment extends CounterEvent &#123;&#125;</span><br><span class="line">class Decrement extends CounterEvent &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 定义状态</span><br><span class="line">class CounterState &#123;</span><br><span class="line">  final int counter;</span><br><span class="line">  CounterState(this.counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义Bloc</span><br><span class="line">class CounterBloc extends Bloc&lt;CounterEvent, CounterState&gt; &#123;</span><br><span class="line">  CounterBloc() : super(CounterState(0));</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Stream&lt;CounterState&gt; mapEventToState(CounterEvent event) async* &#123;</span><br><span class="line">    if (event is Increment) &#123;</span><br><span class="line">      yield CounterState(state.counter + 1);</span><br><span class="line">    &#125; else if (event is Decrement) &#123;</span><br><span class="line">      yield CounterState(state.counter - 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用Bloc</span><br><span class="line">class CounterPage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return BlocProvider(</span><br><span class="line">      create: (context) =&gt; CounterBloc(),</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&#x27;Counter&#x27;)),</span><br><span class="line">        body: BlocBuilder&lt;CounterBloc, CounterState&gt;(</span><br><span class="line">          builder: (context, state) &#123;</span><br><span class="line">            return Center(</span><br><span class="line">              child: Text(&#x27;Counter: $&#123;state.counter&#125;&#x27;),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            FloatingActionButton(</span><br><span class="line">              onPressed: () =&gt; context.read&lt;CounterBloc&gt;().add(Increment()),</span><br><span class="line">              child: Icon(Icons.add),</span><br><span class="line">            ),</span><br><span class="line">            SizedBox(height: 8),</span><br><span class="line">            FloatingActionButton(</span><br><span class="line">              onPressed: () =&gt; context.read&lt;CounterBloc&gt;().add(Decrement()),</span><br><span class="line">              child: Icon(Icons.remove),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Provider结合ChangeNotifier：</strong></p><p>Provider是Flutter推荐的状态管理解决方案之一，通过与ChangeNotifier结合，可以实现简洁而高效的状态管理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:provider/provider.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class Counter with ChangeNotifier &#123;</span><br><span class="line">  int _count = 0;</span><br><span class="line"></span><br><span class="line">  int get count =&gt; _count;</span><br><span class="line"></span><br><span class="line">  void increment() &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void decrement() &#123;</span><br><span class="line">    _count--;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    ChangeNotifierProvider(</span><br><span class="line">      create: (context) =&gt; Counter(),</span><br><span class="line">      child: MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&#x27;Counter&#x27;)),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Consumer&lt;Counter&gt;(</span><br><span class="line">            builder: (context, counter, child) &#123;</span><br><span class="line">              return Text(&#x27;Counter: $&#123;counter.count&#125;&#x27;);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            FloatingActionButton(</span><br><span class="line">              onPressed: () =&gt; context.read&lt;Counter&gt;().increment(),</span><br><span class="line">              child: Icon(Icons.add),</span><br><span class="line">            ),</span><br><span class="line">            SizedBox(height: 8),</span><br><span class="line">            FloatingActionButton(</span><br><span class="line">              onPressed: () =&gt; context.read&lt;Counter&gt;().decrement(),</span><br><span class="line">              child: Icon(Icons.remove),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. <strong>性能优化</strong></h4><p><strong>问题描述：</strong> 应用在渲染复杂界面时出现卡顿，影响用户体验。</p><p><strong>解决方案：</strong></p><ol><li><p><strong>避免不必要的重建：</strong></p><p>使用<code>const</code>关键字来标记不可变的Widget，避免每次构建时不必要的重建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">const MyWidget = Text(&#x27;Hello, Flutter!&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>RepaintBoundary</code>：</strong></p><p>对于复杂的绘制操作，可以使用<code>RepaintBoundary</code>来隔离重绘区域，从而减少重绘的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">RepaintBoundary(</span><br><span class="line">  child: CustomPaint(</span><br><span class="line">    painter: MyPainter(),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>优化ListView：</strong></p><p>对于长列表，使用<code>ListView.builder</code>代替<code>ListView</code>，并确保列表项是轻量级的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">ListView.builder(</span><br><span class="line">  itemCount: 1000,</span><br><span class="line">  itemBuilder: (context, index) &#123;</span><br><span class="line">    return ListTile(</span><br><span class="line">      title: Text(&#x27;Item $index&#x27;),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>缓存图片：</strong></p><p>使用<code>cached_network_image</code>包对网络图片进行缓存，减少网络请求和重绘开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">CachedNetworkImage(</span><br><span class="line">  imageUrl: &#x27;https://example.com/image.jpg&#x27;,</span><br><span class="line">  placeholder: (context, url) =&gt; CircularProgressIndicator(),</span><br><span class="line">  errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Flutter DevTools：</strong></p><p>通过Flutter DevTools分析应用性能，定位性能瓶颈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码</span><br><span class="line">flutter pub global activate devtools</span><br><span class="line">flutter pub global run devtools</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="3-自定义绘制与动画"><a href="#3-自定义绘制与动画" class="headerlink" title="3. 自定义绘制与动画"></a>3. <strong>自定义绘制与动画</strong></h4><p><strong>问题描述：</strong> 在实现复杂动画和自定义绘制时，代码难以维护和扩展。</p><p><strong>解决方案：</strong></p><ol><li><p><strong>使用<code>CustomPainter</code>进行自定义绘制：</strong></p><p>通过<code>CustomPainter</code>实现复杂的绘制逻辑，并结合<code>AnimationController</code>实现动画效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">class MyPainter extends CustomPainter &#123;</span><br><span class="line">  final double progress;</span><br><span class="line"></span><br><span class="line">  MyPainter(this.progress);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    final paint = Paint()</span><br><span class="line">      ..color = Colors.blue</span><br><span class="line">      ..strokeWidth = 4.0</span><br><span class="line">      ..style = PaintingStyle.stroke;</span><br><span class="line"></span><br><span class="line">    final path = Path()</span><br><span class="line">      ..moveTo(0, size.height)</span><br><span class="line">      ..lineTo(size.width * progress, size.height * (1 - progress));</span><br><span class="line"></span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAnimatedWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _MyAnimatedWidgetState createState() =&gt; _MyAnimatedWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyAnimatedWidgetState extends State&lt;MyAnimatedWidget&gt;</span><br><span class="line">    with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  late AnimationController _controller;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    _controller = AnimationController(</span><br><span class="line">      vsync: this,</span><br><span class="line">      duration: Duration(seconds: 2),</span><br><span class="line">    )..repeat(reverse: true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    _controller.dispose();</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return AnimatedBuilder(</span><br><span class="line">      animation: _controller,</span><br><span class="line">      builder: (context, child) &#123;</span><br><span class="line">        return CustomPaint(</span><br><span class="line">          painter: MyPainter(_controller.value),</span><br><span class="line">          child: Container(),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>Flare</code>或<code>Rive</code>实现复杂动画：</strong></p><p><code>Flare</code>和<code>Rive</code>是强大的动画工具，可以在Flutter中轻松实现复杂动画。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">复制代码</span><br><span class="line">dependencies:</span><br><span class="line">  flare_flutter: ^2.0.6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:flare_flutter/flare_actor.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class FlareAnimation extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return FlareActor(</span><br><span class="line">      &quot;assets/flare_animation.flr&quot;,</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      fit: BoxFit.contain,</span><br><span class="line">      animation: &quot;animate&quot;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="4-平台特定代码"><a href="#4-平台特定代码" class="headerlink" title="4. 平台特定代码"></a>4. <strong>平台特定代码</strong></h4><p><strong>问题描述：</strong> 需要在Flutter应用中调用原生平台（iOS&#x2F;Android）的特定功能。</p><p><strong>解决方案：</strong></p><ol><li><p><strong>使用平台通道调用原生代码：</strong></p><p>Flutter通过平台通道提供了与原生代码交互的机制。以下是调用原生代码的示例：</p><p><strong>Android：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">复制代码</span><br><span class="line">// MainActivity.java</span><br><span class="line">import io.flutter.embedding.android.FlutterActivity;</span><br><span class="line">import io.flutter.plugin.common.MethodChannel;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends FlutterActivity &#123;</span><br><span class="line">  private static final String CHANNEL = &quot;com.example.myapp/native&quot;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) &#123;</span><br><span class="line">    super.configureFlutterEngine(flutterEngine);</span><br><span class="line">    new MethodChannel(flutterEngine.getDartExecutor().getBinaryMessenger(), CHANNEL)</span><br><span class="line">        .setMethodCallHandler(</span><br><span class="line">            (call, result) -&gt; &#123;</span><br><span class="line">              if (call.method.equals(&quot;getBatteryLevel&quot;)) &#123;</span><br><span class="line">                int batteryLevel = getBatteryLevel();</span><br><span class="line"></span><br><span class="line">                if (batteryLevel != -1) &#123;</span><br><span class="line">                  result.success(batteryLevel);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  result.error(&quot;UNAVAILABLE&quot;, &quot;Battery level not available.&quot;, null);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                result.notImplemented();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private int getBatteryLevel() &#123;</span><br><span class="line">    int batteryLevel = -1;</span><br><span class="line">    if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">      BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE);</span><br><span class="line">      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Intent intent = new ContextWrapper(getApplicationContext()).registerReceiver(null,</span><br><span class="line">          new IntentFilter(Intent.ACTION_BATTERY_CHANGED));</span><br><span class="line">      batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) /</span><br><span class="line">          intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return batteryLevel;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Flutter：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter/services.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(&#x27;Platform Channel Example&#x27;)),</span><br><span class="line">        body: BatteryLevel(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BatteryLevel extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _BatteryLevelState createState() =&gt; _BatteryLevelState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _BatteryLevelState extends State&lt;BatteryLevel&gt; &#123;</span><br><span class="line">  static const platform = MethodChannel(&#x27;com.example.myapp/native&#x27;);</span><br><span class="line">  String _batteryLevel = &#x27;Unknown battery level.&#x27;;</span><br><span class="line"></span><br><span class="line">  Future&lt;void&gt; _getBatteryLevel() async &#123;</span><br><span class="line">    String batteryLevel;</span><br><span class="line">    try &#123;</span><br><span class="line">      final int result = await platform.invokeMethod(&#x27;getBatteryLevel&#x27;);</span><br><span class="line">      batteryLevel = &#x27;Battery level at $result % .&#x27;;</span><br><span class="line">    &#125; on PlatformException catch (e) &#123;</span><br><span class="line">      batteryLevel = &quot;Failed to get battery level: &#x27;$&#123;e.message&#125;&#x27;.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _batteryLevel = batteryLevel;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Center(</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(_batteryLevel),</span><br><span class="line">          ElevatedButton(</span><br><span class="line">            onPressed: _getBatteryLevel,</span><br><span class="line">            child: Text(&#x27;Get Battery Level&#x27;),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>flutter_native_view</code>包实现自定义平台视图：</strong></p><p>该包允许在Flutter应用中嵌入原生平台视图，适用于需要高度自定义的UI组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">复制代码</span><br><span class="line">dependencies:</span><br><span class="line">  flutter_native_view: ^0.1.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_native_view/flutter_native_view.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class NativeViewExample extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(&#x27;Native View Example&#x27;)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: SizedBox(</span><br><span class="line">          width: 300,</span><br><span class="line">          height: 300,</span><br><span class="line">          child: FlutterNativeView(</span><br><span class="line">            viewType: &#x27;nativeView&#x27;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>iOS：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">objc</span><br><span class="line">复制代码</span><br><span class="line">// AppDelegate.m</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line">#import &lt;Flutter/Flutter.h&gt;</span><br><span class="line">#import &lt;flutter_native_view/FlutterNativeViewPlugin.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NativeViewFactory : NSObject &lt;FlutterPlatformViewFactory&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NativeViewFactory</span><br><span class="line">- (nonnull NSObject&lt;FlutterPlatformView&gt; *)createWithFrame:(CGRect)frame</span><br><span class="line">                                              viewIdentifier:(int64_t)viewId</span><br><span class="line">                                                   arguments:(id _Nullable)args &#123;</span><br><span class="line">  return [[NativeView alloc] initWithFrame:frame viewIdentifier:viewId arguments:args];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NativeView : NSObject &lt;FlutterPlatformView&gt;</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">                viewIdentifier:(int64_t)viewId</span><br><span class="line">                     arguments:(id _Nullable)args;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NativeView</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">                viewIdentifier:(int64_t)viewId</span><br><span class="line">                     arguments:(id _Nullable)args &#123;</span><br><span class="line">  self = [super init];</span><br><span class="line">  if (self) &#123;</span><br><span class="line">    // 初始化视图</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)view &#123;</span><br><span class="line">  UIView *view = [[UIView alloc] initWithFrame:CGRectZero];</span><br><span class="line">  view.backgroundColor = [UIColor blueColor];</span><br><span class="line">  return view;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AppDelegate</span><br><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">  FlutterViewController *controller = (FlutterViewController *)self.window.rootViewController;</span><br><span class="line">  FlutterNativeViewPlugin *plugin = [[FlutterNativeViewPlugin alloc] initWithMessenger:controller];</span><br><span class="line">  [plugin registerViewFactory:[[NativeViewFactory alloc] init] withId:@&quot;nativeView&quot;];</span><br><span class="line">  return [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="5-网络请求与数据处理"><a href="#5-网络请求与数据处理" class="headerlink" title="5. 网络请求与数据处理"></a>5. <strong>网络请求与数据处理</strong></h4><p><strong>问题描述：</strong> 在处理复杂网络请求和数据处理时，可能会遇到性能瓶颈和数据一致性问题。</p><p><strong>解决方案：</strong></p><ol><li><p><strong>使用<code>dio</code>库处理复杂网络请求：</strong></p><p><code>dio</code>是一个强大的Dart HTTP请求库，支持拦截器、全局配置、表单数据、文件上传&#x2F;下载、请求取消等功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">复制代码</span><br><span class="line">dependencies:</span><br><span class="line">  dio: ^4.0.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:dio/dio.dart&#x27;;</span><br><span class="line"></span><br><span class="line">class ApiService &#123;</span><br><span class="line">  final Dio _dio = Dio(BaseOptions(baseUrl: &#x27;https://api.example.com&#x27;));</span><br><span class="line"></span><br><span class="line">  Future&lt;Response&gt; getData(String endpoint) async &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      final response = await _dio.get(endpoint);</span><br><span class="line">      return response;</span><br><span class="line">    &#125; on DioError catch (e) &#123;</span><br><span class="line">      // 处理错误</span><br><span class="line">      throw Exception(&#x27;Failed to load data: $&#123;e.message&#125;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>json_serializable</code>库进行JSON序列化：</strong></p><p>通过<code>json_serializable</code>库，可以自动生成数据类的序列化和反序列化代码，简化数据处理逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yaml</span><br><span class="line">复制代码</span><br><span class="line">dependencies:</span><br><span class="line">  json_annotation: ^4.0.1</span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  build_runner: ^2.0.0</span><br><span class="line">  json_serializable: ^5.0.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dart</span><br><span class="line">复制代码</span><br><span class="line">import &#x27;package:json_annotation/json_annotation.dart&#x27;;</span><br><span class="line"></span><br><span class="line">part &#x27;user.g.dart&#x27;;</span><br><span class="line"></span><br><span class="line">@JsonSerializable()</span><br><span class="line">class User &#123;</span><br><span class="line">  final int id;</span><br><span class="line">  final String name;</span><br><span class="line">  final String email;</span><br><span class="line"></span><br><span class="line">  User(&#123;required this.id, required this.name, required this.email&#125;);</span><br><span class="line"></span><br><span class="line">  factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);</span><br><span class="line">  Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以下命令生成序列化代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码</span><br><span class="line">flutter pub run build_runner build</span><br></pre></td></tr></table></figure></li></ol><hr><p>希望这些解决方案能帮助你解决在Flutter开发过程中遇到的深度疑难杂症。如果你有其他问题或需要更多帮助，欢迎留言讨论！</p><hr>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADB 常用命令</title>
      <link href="/blog/2022/04/16/ADB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2022/04/16/ADB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="常用的ADB命令"><a href="#常用的ADB命令" class="headerlink" title="常用的ADB命令"></a>常用的ADB命令</h4><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h5 id="连接USB"><a href="#连接USB" class="headerlink" title="连接USB"></a>连接USB</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb usb</span><br></pre></td></tr></table></figure><h5 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure><h5 id="连接局域网手机"><a href="#连接局域网手机" class="headerlink" title="连接局域网手机"></a>连接局域网手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 192.168.x.x:5555</span><br></pre></td></tr></table></figure><h5 id="断开所有连接"><a href="#断开所有连接" class="headerlink" title="断开所有连接"></a>断开所有连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure><h5 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure><h5 id="查看已连接手机"><a href="#查看已连接手机" class="headerlink" title="查看已连接手机"></a>查看已连接手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><h5 id="断开手机连接"><a href="#断开手机连接" class="headerlink" title="断开手机连接"></a>断开手机连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb disconnect 192.168.x.x</span><br></pre></td></tr></table></figure><h5 id="指定端口号"><a href="#指定端口号" class="headerlink" title="指定端口号"></a>指定端口号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -p 5555 start-server</span><br></pre></td></tr></table></figure><ul><li>默认为5037</li></ul><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><h5 id="android-系统版本号"><a href="#android-系统版本号" class="headerlink" title="android 系统版本号"></a>android 系统版本号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><h5 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure><h5 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><h5 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><p>更多系统信息:</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>ro.build.version.sdk</td><td>SDK 版本</td></tr><tr><td>ro.build.version.release</td><td>Android 系统版本</td></tr><tr><td>ro.build.version.security_patch</td><td>Android 安全补丁程序级别</td></tr><tr><td>ro.product.model</td><td>型号</td></tr><tr><td>ro.product.brand</td><td>品牌</td></tr><tr><td>ro.product.name</td><td>设备名</td></tr><tr><td>ro.product.board</td><td>处理器型号</td></tr><tr><td>ro.product.cpu.abilist</td><td>CPU 支持的 abi 列表[<em>节注一</em>]</td></tr><tr><td>persist.sys.isUsbOtgEnabled</td><td>是否支持 OTG</td></tr><tr><td>dalvik.vm.heapsize</td><td>每个应用程序的内存上限</td></tr><tr><td>ro.sf.lcd_density</td><td>屏幕密度</td></tr></tbody></table></li></ul><h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure><p>  各列含义：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>所属用户</td></tr><tr><td>PID</td><td>进程 ID</td></tr><tr><td>PPID</td><td>父进程 ID</td></tr><tr><td>NAME</td><td>进程名</td></tr></tbody></table><h5 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure><p>  各列含义：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程 ID</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>CPU%</td><td>当前瞬间占用 CPU 百分比</td></tr><tr><td>S</td><td>进程状态（R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）</td></tr><tr><td>#THR</td><td>线程数</td></tr><tr><td>VSS</td><td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td></tr><tr><td>RSS</td><td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td></tr><tr><td>PCY</td><td>调度策略优先级，SP_BACKGROUND&#x2F;SPFOREGROUND</td></tr><tr><td>UID</td><td>进程所有者的用户 ID</td></tr><tr><td>NAME</td><td>进程名</td></tr></tbody></table><h5 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package &lt;pn&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h5 id="指定端口号-1"><a href="#指定端口号-1" class="headerlink" title="指定端口号"></a>指定端口号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -p 5555 start-server</span><br></pre></td></tr></table></figure><ul><li>默认为5037</li></ul><hr><h3 id="查看应用于交互"><a href="#查看应用于交互" class="headerlink" title="查看应用于交互"></a>查看应用于交互</h3><ul><li><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下:</p><ul><li><table><thead><tr><th>command</th><th>用途</th></tr></thead><tbody><tr><td><code>start [options] &lt;INTENT&gt;</code></td><td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td></tr><tr><td><code>startservice [options] &lt;INTENT&gt;</code></td><td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td></tr><tr><td><code>broadcast [options] &lt;INTENT&gt;</code></td><td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td></tr><tr><td><code>force-stop &lt;packagename&gt;</code></td><td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td></tr></tbody></table></li><li><p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p><p>用于决定 intent 对象的选项如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-a &lt;ACTION&gt;</code></td><td>指定 action，比如 <code>android.intent.action.VIEW</code></td></tr><tr><td><code>-c &lt;CATEGORY&gt;</code></td><td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td></tr><tr><td><code>-n &lt;COMPONENT&gt;</code></td><td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td></tr></tbody></table><p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>--esn &lt;EXTRA_KEY&gt;</code></td><td>null 值（只有 key 名）</td></tr><tr><td>&#96;-e</td><td>–es <EXTRA_KEY> <EXTRA_STRING_VALUE>&#96;</td></tr><tr><td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td><td>boolean 值</td></tr><tr><td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td><td>integer 值</td></tr><tr><td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td><td>long 值</td></tr><tr><td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td><td>float 值</td></tr><tr><td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td><td>URI</td></tr><tr><td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td><td>component name</td></tr><tr><td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td><td>integer 数组</td></tr><tr><td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td><td>long 数组</td></tr></tbody></table></li></ul></li></ul><h5 id="查看前台Activity"><a href="#查看前台Activity" class="headerlink" title="查看前台Activity"></a>查看前台Activity</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure><h5 id="安卓App"><a href="#安卓App" class="headerlink" title="安卓App"></a>安卓App</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install</span><br></pre></td></tr></table></figure><p>  后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下:</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-l</td><td>将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td></tr><tr><td>-r</td><td>允许覆盖安装</td></tr><tr><td>-t</td><td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td></tr><tr><td>-s</td><td>将应用安装到 sdcard</td></tr><tr><td>-d</td><td>允许降级覆盖安装</td></tr><tr><td>-g</td><td>授予所有运行时权限</td></tr></tbody></table><h5 id="卸载App"><a href="#卸载App" class="headerlink" title="卸载App"></a>卸载App</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p>  -k为可选参数,表示卸载后保留缓存目录</p><h5 id="截图保存到当前那文件夹"><a href="#截图保存到当前那文件夹" class="headerlink" title="截图保存到当前那文件夹"></a>截图保存到当前那文件夹</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure><h5 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h5><ul><li><p>录制屏幕以 mp4 格式保存到 &#x2F;sdcard：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure><p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p><p>如果需要导出到电脑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure></li></ul><h5 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h5 id="清楚应用缓存"><a href="#清楚应用缓存" class="headerlink" title="清楚应用缓存"></a>清楚应用缓存</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear &lt;pn&gt;</span><br></pre></td></tr></table></figure><h5 id="显示虚拟按键"><a href="#显示虚拟按键" class="headerlink" title="显示虚拟按键"></a>显示虚拟按键</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice -n com.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure><h5 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop &lt;pn&gt;adb reboot</span><br></pre></td></tr></table></figure><hr><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h5 id="复制设备文件到电脑"><a href="#复制设备文件到电脑" class="headerlink" title="复制设备文件到电脑"></a>复制设备文件到电脑</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &lt;设备路径&gt; [电脑目录]</span><br></pre></td></tr></table></figure><ul><li>不设置电脑目录,默认复制到当前文件夹下</li></ul><h5 id="复制电脑文件到手机"><a href="#复制电脑文件到手机" class="headerlink" title="复制电脑文件到手机"></a>复制电脑文件到手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push &lt;电脑路径&gt; &lt;设备目录&gt;</span><br></pre></td></tr></table></figure><ul><li>adb push ~&#x2F;sr.mp4 &#x2F;sdcard&#x2F;</li></ul><h3 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键&#x2F;输入"></a>模拟按键&#x2F;输入</h3><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p><h5 id="模拟按键"><a href="#模拟按键" class="headerlink" title="模拟按键"></a>模拟按键</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent &lt;keycode&gt;</span><br></pre></td></tr></table></figure><p>  - </p><table><thead><tr><th>keycode</th><th>含义</th></tr></thead><tbody><tr><td>3</td><td>HOME 键</td></tr><tr><td>4</td><td>返回键</td></tr><tr><td>5</td><td>打开拨号应用</td></tr><tr><td>6</td><td>挂断电话</td></tr><tr><td>24</td><td>增加音量</td></tr><tr><td>25</td><td>降低音量</td></tr><tr><td>26</td><td>电源键</td></tr><tr><td>27</td><td>拍照（需要在相机应用里）</td></tr><tr><td>64</td><td>打开浏览器</td></tr><tr><td>82</td><td>菜单键</td></tr><tr><td>85</td><td>播放&#x2F;暂停</td></tr><tr><td>86</td><td>停止播放</td></tr><tr><td>87</td><td>播放下一首</td></tr><tr><td>88</td><td>播放上一首</td></tr><tr><td>122</td><td>移动光标到行首或列表顶部</td></tr><tr><td>123</td><td>移动光标到行末或列表底部</td></tr><tr><td>126</td><td>恢复播放</td></tr><tr><td>127</td><td>暂停播放</td></tr><tr><td>164</td><td>静音</td></tr><tr><td>176</td><td>打开系统设置</td></tr><tr><td>187</td><td>切换应用</td></tr><tr><td>207</td><td>打开联系人</td></tr><tr><td>208</td><td>打开日历</td></tr><tr><td>209</td><td>打开音乐</td></tr><tr><td>210</td><td>打开计算器</td></tr><tr><td>220</td><td>降低屏幕亮度</td></tr><tr><td>221</td><td>提高屏幕亮度</td></tr><tr><td>223</td><td>系统休眠</td></tr><tr><td>224</td><td>点亮屏幕</td></tr><tr><td>231</td><td>打开语音助手</td></tr><tr><td>276</td><td>如果没有 wakelock 则让系统休眠</td></tr></tbody></table><h5 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure><p>执行效果相当于按电源键。</p><h5 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure><h5 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure><h5 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure><h5 id="增加音量："><a href="#增加音量：" class="headerlink" title="增加音量："></a>增加音量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure><h5 id="降低音量："><a href="#降低音量：" class="headerlink" title="降低音量："></a>降低音量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure><h5 id="静音："><a href="#静音：" class="headerlink" title="静音："></a>静音：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure><h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><h5 id="播放-暂停："><a href="#播放-暂停：" class="headerlink" title="播放&#x2F;暂停："></a>播放&#x2F;暂停：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure><h5 id="停止播放："><a href="#停止播放：" class="headerlink" title="停止播放："></a>停止播放：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure><h5 id="播放下一首："><a href="#播放下一首：" class="headerlink" title="播放下一首："></a>播放下一首：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure><h5 id="播放上一首："><a href="#播放上一首：" class="headerlink" title="播放上一首："></a>播放上一首：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure><h5 id="恢复播放："><a href="#恢复播放：" class="headerlink" title="恢复播放："></a>恢复播放：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure><h5 id="暂停播放："><a href="#暂停播放：" class="headerlink" title="暂停播放："></a>暂停播放：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure><h3 id="点亮-熄灭屏幕"><a href="#点亮-熄灭屏幕" class="headerlink" title="点亮&#x2F;熄灭屏幕"></a>点亮&#x2F;熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p><h5 id="点亮屏幕："><a href="#点亮屏幕：" class="headerlink" title="点亮屏幕："></a>点亮屏幕：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure><h5 id="熄灭屏幕："><a href="#熄灭屏幕：" class="headerlink" title="熄灭屏幕："></a>熄灭屏幕：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure><h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p><p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure><p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p><h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure><p>现在 <code>hello</code> 出现在文本框了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin扩展函数（一）</title>
      <link href="/blog/2021/08/09/Kotlin%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%90%88%E9%9B%86/"/>
      <url>/blog/2021/08/09/Kotlin%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Kotlin中集合Collection"><a href="#Kotlin中集合Collection" class="headerlink" title="Kotlin中集合Collection"></a>Kotlin中集合Collection</h3><h4 id="使用"><a href="#使用" class="headerlink" title="[使用]"></a>[使用]</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;androidx.collection:collection-ktx:x.x.x&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="[用法]"></a>[用法]</h4><p>Kotlin 的集合框架提供了丰富的扩展函数，这些函数可以帮助我们方便地操作和处理集合数据。本文将详细介绍一些常用的集合扩展函数及其用法。</p><h4 id="Collection-扩展函数"><a href="#Collection-扩展函数" class="headerlink" title="Collection 扩展函数"></a>Collection 扩展函数</h4><ul><li><p><code>filterNot()</code>：返回一个新的集合，包含原集合中不满足给定条件的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val numbers = listOf(1, 2, 3, 4, 5)</span><br><span class="line">val evenNumbers = numbers.filterNot &#123; it % 2 != 0 &#125;</span><br><span class="line">println(evenNumbers) // 输出: [2, 4]</span><br></pre></td></tr></table></figure></li><li><p><code>filterNotNull()</code>：返回一个新的集合，过滤掉所有 null 元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val numbers = listOf(1, null, 3, null, 5)</span><br><span class="line">val nonNullNumbers = numbers.filterNotNull()</span><br><span class="line">println(nonNullNumbers) // 输出: [1, 3, 5]</span><br></pre></td></tr></table></figure></li></ul><h4 id="List-扩展函数"><a href="#List-扩展函数" class="headerlink" title="List 扩展函数"></a>List 扩展函数</h4><ul><li><p><code>sorted()</code>：返回一个新的 List，按自然顺序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val numbers = listOf(5, 3, 1, 4, 2)</span><br><span class="line">val sortedNumbers = numbers.sorted()</span><br><span class="line">println(sortedNumbers) // 输出: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li><li><p><code>sortedBy()</code>：返回一个新的 List，按指定的方式排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码data class Person(val name: String, val age: Int)</span><br><span class="line">val people = listOf(Person(&quot;Alice&quot;, 30), Person(&quot;Bob&quot;, 25), Person(&quot;Charlie&quot;, 35))</span><br><span class="line">val sortedPeople = people.sortedBy &#123; it.age &#125;</span><br><span class="line">println(sortedPeople) // 输出: [Person(name=Bob, age=25), Person(name=Alice, age=30), Person(name=Charlie, age=35)]</span><br></pre></td></tr></table></figure></li><li><p><code>sortedDescending()</code>：返回一个新的 List，按自然顺序降序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val numbers = listOf(5, 3, 1, 4, 2)</span><br><span class="line">val sortedNumbers = numbers.sortedDescending()</span><br><span class="line">println(sortedNumbers) // 输出: [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure></li><li><p><code>sortedByDescending()</code>：返回一个新的 List，按指定的方式降序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码data class Person(val name: String, val age: Int)</span><br><span class="line">val people = listOf(Person(&quot;Alice&quot;, 30), Person(&quot;Bob&quot;, 25), Person(&quot;Charlie&quot;, 35))</span><br><span class="line">val sortedPeople = people.sortedByDescending &#123; it.age &#125;</span><br><span class="line">println(sortedPeople) // 输出: [Person(name=Charlie, age=35), Person(name=Alice, age=30), Person(name=Bob, age=25)]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Set-扩展函数"><a href="#Set-扩展函数" class="headerlink" title="Set 扩展函数"></a>Set 扩展函数</h4><ul><li><p><code>union()</code>：返回一个包含两个集合中所有元素的 Set，不包含重复元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val set1 = setOf(1, 2, 3)</span><br><span class="line">val set2 = setOf(3, 4, 5)</span><br><span class="line">val unionSet = set1.union(set2)</span><br><span class="line">println(unionSet) // 输出: [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li><li><p><code>intersect()</code>：返回一个包含两个集合中公共元素的 Set。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlinval set1 = setOf(1, 2, 3)</span><br><span class="line">val set2 = setOf(3, 4, 5)</span><br><span class="line">val intersectSet = set1.intersect(set2)</span><br><span class="line">println(intersectSet) // 输出: [3]</span><br></pre></td></tr></table></figure></li><li><p><code>subtract()</code>：返回一个包含从第一个集合中减去第二个集合中的元素的 Set。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kotlinval set1 = setOf(1, 2, 3)</span><br><span class="line">val set2 = setOf(3, 4, 5)</span><br><span class="line">val subtractSet = set1.subtract(set2)</span><br><span class="line">println(subtractSet) // 输出: [1, 2]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Map-扩展函数"><a href="#Map-扩展函数" class="headerlink" title="Map 扩展函数"></a>Map 扩展函数</h4><ul><li><p><code>mapKeys()</code>：返回一个包含将原 Map 的键变换后的新 Map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</span><br><span class="line">val newMap = map.mapKeys &#123; it.key.toUpperCase() &#125;</span><br><span class="line">println(newMap) // 输出: &#123;A=1, B=2, C=3&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>mapValues()</code>：返回一个包含将原 Map 的值变换后的新 Map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</span><br><span class="line">val newMap = map.mapValues &#123; it.value * 2 &#125;</span><br><span class="line">println(newMap) // 输出: &#123;a=2, b=4, c=6&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>filterKeys()</code>：返回一个包含原 Map 中符合指定条件的键的键值对的新 Map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</span><br><span class="line">val filteredMap = map.filterKeys &#123; it != &quot;b&quot; &#125;</span><br><span class="line">println(filteredMap) // 输出: &#123;a=1, c=3&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>filterValues()</code>：返回一个包含原 Map 中符合指定条件的值的键值对的新 Map。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</span><br><span class="line">val filteredMap = map.filterValues &#123; it &gt; 1 &#125;</span><br><span class="line">println(filteredMap) // 输出: &#123;b=2, c=3&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过使用这些集合扩展函数，可以更加高效地操作和处理集合数据，从而提高代码的可读性和可维护性。希望本文对你有所帮助，如果有任何疑问或建议，欢迎在评论区交流讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扩展 </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 常用命令</title>
      <link href="/blog/2020/08/18/Flutter-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2020/08/18/Flutter-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>查看具体命令帮助信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter help &lt;command&gt;&lt;/command&gt;</span><br></pre></td></tr></table></figure><p>查看flutter SDK所有分支</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter channel</span><br></pre></td></tr></table></figure><p>切换分支（例如切换到stable分支）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter channel stable</span><br></pre></td></tr></table></figure><p>flutter环境诊断</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>查看详细信息</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor -v</span><br></pre></td></tr></table></figure><p>flutter版本升级</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure><p>获取项目所有的依赖包</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><p>获取项目所有依赖包的最新版本</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages upgrade</span><br></pre></td></tr></table></figure><p>添加第三方（例如添加xmpp_plugin）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add xmpp_plugin</span><br></pre></td></tr></table></figure><p>获取第三方包依赖</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub get</span><br></pre></td></tr></table></figure><p>清缓存</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter clean</span><br></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>列出所有连接的设备</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter devices</span><br></pre></td></tr></table></figure><p>运行项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure><p>显示系统日志运行</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run --verbose-system-logs</span><br></pre></td></tr></table></figure><p>指定设备运行项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d &#x27;iPhone Xʀ&#x27;</span><br></pre></td></tr></table></figure><p>运行在所有可用设备上</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d all</span><br></pre></td></tr></table></figure><p>查看可用模拟器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter emulators</span><br></pre></td></tr></table></figure><p>启动iOS模拟器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter emulators --launch apple_ios_simulator</span><br></pre></td></tr></table></figure><p>启动Android 模拟器-只有启动模拟器才可以运行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter emulators --launch Nexus_5X_API_27</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d emulator-5554</span><br></pre></td></tr></table></figure><p>运行IOS真机</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d 00008020-001838491169002E</span><br></pre></td></tr></table></figure><p>查看日志</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter logs</span><br></pre></td></tr></table></figure><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>创建项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create flutter_app</span><br></pre></td></tr></table></figure><p>指定语言：默认Android使用Java，iOS使用Objective-C</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create -i swift -a kotlin flutter_app</span><br></pre></td></tr></table></figure><p>创建混编项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create -t module flutter_module</span><br></pre></td></tr></table></figure><p>旧项目新增平台支持</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --platforms=windows,macos,linux .</span><br></pre></td></tr></table></figure><p>开启平台</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-web true</span><br></pre></td></tr></table></figure><p>关闭平台（关闭后可以删除项目中对应的平台目录文件夹）</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --no-enable-web</span><br></pre></td></tr></table></figure><p>开启和关闭平台后都需要使用命令重新构建下项目（最好都关闭项目然后在终端中cd到当前项目目录后执行命令）</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create .</span><br></pre></td></tr></table></figure><p> 如果报错的话用下面这个(上面的旧项目新增平台的命令如果报错也可以试试这个命令)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --org package_name .</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>分析代码</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter analyze</span><br></pre></td></tr></table></figure><p>构建iOS</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build ios</span><br></pre></td></tr></table></figure><p>安卓打包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk</span><br></pre></td></tr></table></figure><p>iOS打包，运行命令后在xcode中打包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build ios --release</span><br></pre></td></tr></table></figure><p>打包web，文件在build目录下</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build web</span><br></pre></td></tr></table></figure><p>截图</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter screenshot</span><br></pre></td></tr></table></figure><p>清除插件缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub cache repair</span><br></pre></td></tr></table></figure><p>创建插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --org com.example --template=plugin --platforms=android,ios,linux,macos,windows -a kotlin project-name</span><br></pre></td></tr></table></figure><p>安卓打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#arm64</span><br><span class="line">flutter build apk --release --split-per-abi --build-number=1 --build-name=wuhope --tree-shake-icons --analyze-size --target-platform=android-arm64</span><br><span class="line"></span><br><span class="line">#x86</span><br><span class="line">flutter build apk --release --split-per-abi --build-number=1 --build-name=wuhope --tree-shake-icons --analyze-size --target-platform=android-x64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android虚拟机Dalvik &amp;&amp; ART</title>
      <link href="/blog/2020/04/03/Android%E8%99%9A%E6%8B%9F%E6%9C%BADalvik-ART/"/>
      <url>/blog/2020/04/03/Android%E8%99%9A%E6%8B%9F%E6%9C%BADalvik-ART/</url>
      
        <content type="html"><![CDATA[<h4 id="安卓虚拟机"><a href="#安卓虚拟机" class="headerlink" title="安卓虚拟机"></a>安卓虚拟机</h4><h5 id="安卓虚拟机可以大致分为两大类"><a href="#安卓虚拟机可以大致分为两大类" class="headerlink" title="安卓虚拟机可以大致分为两大类:"></a>安卓虚拟机可以大致分为两大类:</h5><ol><li>5.0之前的Dalvik</li><li>5.0之后ART逐渐取代Dalvik</li></ol><hr><h3 id="一-Dalvik"><a href="#一-Dalvik" class="headerlink" title="(一) Dalvik"></a>(一) Dalvik</h3><h4 id="dalvik和JVM的区别"><a href="#dalvik和JVM的区别" class="headerlink" title="dalvik和JVM的区别"></a>dalvik和JVM的区别</h4><blockquote><p>dalvik运行的是dalvik字节码,是由java字节码转换过来,打包到dex中,JVM运行的是calss或者jar.</p></blockquote><blockquote><p>dex比jar运行速度更快,dex会把所有的信息整合到一起,去掉冗余信息,优化I&#x2F;O操作,提高查找速度.</p></blockquote><blockquote><p>dalvik是基于寄存器,JVM是基于操作数栈,基于寄存器执行效率高,但是可移植性差.</p></blockquote><blockquote><p>dalvik可以在有限的内存中运行多个进程,每一个应用都运行在自己的Dalvik虚拟机当中,拥有独立的进程.</p></blockquote><hr><h4 id="JIT-Just-In-Time-Compile"><a href="#JIT-Just-In-Time-Compile" class="headerlink" title="JIT(Just-In-Time Compile)"></a>JIT(Just-In-Time Compile)</h4><blockquote><p>在没有JIT之前,虚拟机运行时会通过解释器将字节码翻译为机器码,逐条读入然后翻译,这样会导致效率很慢,后来引入JIT 是一种优化的手段,及时编译,JIT会将热点代码翻译后缓存起来,下次执行的时候直接读取缓存,JIT的缺点:<code>每次重新启动都需要重新翻译</code>,<code>运行的时候比较耗电</code></p></blockquote><hr><h4 id="dex和Odex"><a href="#dex和Odex" class="headerlink" title="dex和Odex"></a>dex和Odex</h4><blockquote><p>dex是将所有的class文件优化合并后的文件,与jar文件不同的是,jar文件就像文件夹,里面的class文件是单独的.</p></blockquote><blockquote><p>在Dalvik虚拟机中，会通过dexopt来对dex进行优化，生成odex文件，并将其保存到手机的VM缓存文件夹data&#x2F;dalvik-cache下（注意，这边生成的odex文件后缀依然是dex ）。它是一个dey文件，里面仍然还是字节码。</p></blockquote><hr><h3 id="二-ART"><a href="#二-ART" class="headerlink" title="(二)ART"></a>(二)ART</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>ART是在android5.0逐渐引进代替dalvik虚拟机,它不再使用JIT而是使用AOT的提前编译优化,以及垃圾回收机制也做了升级和优化等</p></blockquote><hr><h4 id="AOT-Ahead-Of-Time"><a href="#AOT-Ahead-Of-Time" class="headerlink" title="AOT(Ahead-Of-Time)"></a>AOT(Ahead-Of-Time)</h4><blockquote><p>AOT会提前将字节码编译为机器码,保存在磁盘当中,运行的时候直接执行,</p></blockquote><blockquote><p>在7.0之前应用在安装的时候会进行一次预编译,生成.oat文件保存在本地,但是这样也使得安装的时间大大增大,于是又引进了JIT技术,形成一种JIT和AOT混合编译模式,它的特点是:<br>1 安装的时候不进行预编译<br>2 应用运行的时候直接使用JIT进行编译,然后记录代码信息到profile文件中<br>3 手机在空闲状态下手机会扫描profile文件,并通过AOT对热点代码进行编译,下次再运行的时候会根据profile来执行已编译的机器码</p></blockquote><h4 id="垃圾回收方面的优化"><a href="#垃圾回收方面的优化" class="headerlink" title="垃圾回收方面的优化"></a>垃圾回收方面的优化</h4><blockquote><p>垃圾回收判定:<br>ART采用的是<code>可达性分析算法</code></p></blockquote><blockquote><p>垃圾回收算法:<br>JVM上:<code>标记-整理</code>,<code>标记-清除</code>,<code>标记-复制</code>,<code>分带算法</code><br>ART上会根据前后台状态进行分类:<br>前台状态下ART采用:<code>标记-整理</code>,<code>标记-复制</code> (ART在标记复制算法上做了优化)<br>后台状态下ART采用:<code>CMS(并发标记清理)</code>。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkIO详解</title>
      <link href="/blog/2019/08/06/OkIO%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2019/08/06/OkIO%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="OKIO详解"><a href="#OKIO详解" class="headerlink" title="OKIO详解"></a>OKIO详解</h1><p>OKIO是一个由Square公司开发的高效、易用的I&#x2F;O库，广泛用于处理文件和网络I&#x2F;O。OKIO通过提供简单的API和丰富的功能，极大地简化了字节流和字符流的操作。本文将详细解析OKIO的基本用法、核心功能及其一些高级特性，并结合实例帮助读者更好地理解和应用OKIO。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#okio%E8%AF%A6%E8%A7%A3">OKIO详解</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE">依赖配置</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a><ul><li><a href="#sink">Sink</a></li><li><a href="#source">Source</a></li><li><a href="#buffer">Buffer</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a><ul><li><a href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE">写入数据</a></li><li><a href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">读取数据</a></li></ul></li><li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">文件操作</a><ul><li><a href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">复制文件</a></li></ul></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">网络操作</a><ul><li><a href="#%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">从网络读取数据</a></li></ul></li><li><a href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">高级特性</a><ul><li><a href="#%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2">字节字符串</a></li><li><a href="#%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6">超时控制</a></li></ul></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OKIO是一个简洁而高效的I&#x2F;O库，提供了类似于Java I&#x2F;O的功能，但更简洁、更高效。它解决了Java I&#x2F;O的一些常见问题，如缓冲区管理、字符集转换和错误处理等。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>在项目的<code>build.gradle</code>文件中添加以下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groovydependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.okio:okio:3.0.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>OKIO的核心概念包括Sink、Source和Buffer。这些类提供了读写字节和字符的基本操作。</p><h3 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h3><p>Sink表示一个字节流的目标，可以是文件、网络连接等。通过Sink，你可以将数据写入到目标中。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source表示一个字节流的来源，可以是文件、网络连接等。通过Source，你可以从来源中读取数据。</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>Buffer是一个中间缓冲区，用于存储读写操作中的数据。它提供了高效的读写操作，简化了字节和字符的转换。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p>使用Sink可以将数据写入文件或其他目标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.Buffer;</span><br><span class="line">import okio.BufferedSink;</span><br><span class="line">import okio.Okio;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class OkioWriteExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File file = new File(&quot;example.txt&quot;);</span><br><span class="line">        try (BufferedSink sink = Okio.buffer(Okio.sink(file))) &#123;</span><br><span class="line">            sink.writeUtf8(&quot;Hello, OKIO!&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>使用Source可以从文件或其他来源读取数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.Buffer;</span><br><span class="line">import okio.BufferedSource;</span><br><span class="line">import okio.Okio;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class OkioReadExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File file = new File(&quot;example.txt&quot;);</span><br><span class="line">        try (BufferedSource source = Okio.buffer(Okio.source(file))) &#123;</span><br><span class="line">            String data = source.readUtf8();</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>OKIO可以方便地进行文件操作，如读写文件、复制文件等。</p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.Okio;</span><br><span class="line">import okio.Source;</span><br><span class="line">import okio.Sink;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class OkioFileCopyExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File sourceFile = new File(&quot;source.txt&quot;);</span><br><span class="line">        File destinationFile = new File(&quot;destination.txt&quot;);</span><br><span class="line"></span><br><span class="line">        try (Source source = Okio.source(sourceFile);</span><br><span class="line">             Sink sink = Okio.sink(destinationFile)) &#123;</span><br><span class="line">            Okio.buffer(sink).writeAll(source);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p>OKIO也可以用于网络操作，如从网络读取数据或向网络发送数据。</p><h3 id="从网络读取数据"><a href="#从网络读取数据" class="headerlink" title="从网络读取数据"></a>从网络读取数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.BufferedSource;</span><br><span class="line">import okio.Okio;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class OkioNetworkExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            URL url = new URL(&quot;https://www.example.com&quot;);</span><br><span class="line">            BufferedSource source = Okio.buffer(Okio.source(url.openStream()));</span><br><span class="line">            String data = source.readUtf8();</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="字节字符串"><a href="#字节字符串" class="headerlink" title="字节字符串"></a>字节字符串</h3><p>OKIO提供了<code>ByteString</code>类，用于高效处理不可变的字节序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.ByteString;</span><br><span class="line"></span><br><span class="line">public class OkioByteStringExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteString byteString = ByteString.encodeUtf8(&quot;Hello, OKIO!&quot;);</span><br><span class="line">        System.out.println(byteString.utf8());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>OKIO允许设置读写操作的超时时间，以防止长时间等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.Buffer;</span><br><span class="line">import okio.BufferedSource;</span><br><span class="line">import okio.Timeout;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class OkioTimeoutExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Buffer buffer = new Buffer();</span><br><span class="line">        buffer.writeUtf8(&quot;Hello, OKIO!&quot;);</span><br><span class="line"></span><br><span class="line">        BufferedSource source = buffer;</span><br><span class="line">        source.timeout().timeout(5, java.util.concurrent.TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(source.readUtf8());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个综合示例，演示了OKIO的读写文件操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">javaimport okio.BufferedSink;</span><br><span class="line">import okio.BufferedSource;</span><br><span class="line">import okio.Okio;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class OkioExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        File file = new File(&quot;example.txt&quot;);</span><br><span class="line"></span><br><span class="line">        // 写入数据</span><br><span class="line">        try (BufferedSink sink = Okio.buffer(Okio.sink(file))) &#123;</span><br><span class="line">            sink.writeUtf8(&quot;Hello, OKIO!&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 读取数据</span><br><span class="line">        try (BufferedSource source = Okio.buffer(Okio.source(file))) &#123;</span><br><span class="line">            String data = source.readUtf8();</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OKIO是一个强大且灵活的I&#x2F;O库，通过简洁的API和高效的实现，极大地简化了文件和网络的读写操作。无论是基本的文件读写，还是复杂的网络操作，OKIO都提供了全面的支持。通过本文的介绍，希望读者能够掌握OKIO的基本用法，并在实际项目中灵活运用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OkIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Okhttp详解</title>
      <link href="/blog/2019/03/09/Okhttp%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2019/03/09/Okhttp%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="OKHttp详解"><a href="#OKHttp详解" class="headerlink" title="OKHttp详解"></a>OKHttp详解</h1><p>OKHttp是一个高效的HTTP客户端库，广泛应用于Android开发中。它提供了便捷的API来进行网络请求，并且具备出色的性能和灵活性。本文将详细解析OKHttp的基本用法、核心功能以及一些高级特性。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#okhttp%E8%AF%A6%E8%A7%A3">OKHttp详解</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE">依赖配置</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a><ul><li><a href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82">同步请求</a></li><li><a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82">异步请求</a></li></ul></li><li><a href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94">请求和响应</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD">常见功能</a><ul><li><a href="#%E8%AF%B7%E6%B1%82%E5%A4%B4">请求头</a></li><li><a href="#%E8%AF%B7%E6%B1%82%E4%BD%93">请求体</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a></li><li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li><li><a href="#%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE">超时设置</a></li></ul></li><li><a href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">高级特性</a><ul><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0">连接池</a></li><li><a href="#websocket">WebSocket</a></li></ul></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OKHttp由Square公司开发，是一个轻量级且功能强大的HTTP客户端库，支持HTTP&#x2F;2、WebSocket、透明压缩和连接池复用等特性。它不仅可以用于Android开发，也可以在Java项目中使用。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>在项目的<code>build.gradle</code>文件中添加以下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groovydependencies &#123;</span><br><span class="line">    implementation &#x27;com.squareup.okhttp3:okhttp:4.9.3&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><p>同步请求会阻塞当前线程，直到服务器返回响应。适用于在后台线程进行网络操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaOkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/getData&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    if (response.isSuccessful()) &#123;</span><br><span class="line">        System.out.println(response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>异步请求不会阻塞当前线程，而是通过回调接口处理响应。适用于在UI线程进行网络操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaOkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/getData&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">        if (response.isSuccessful()) &#123;</span><br><span class="line">            System.out.println(response.body().string());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>OKHttp的请求和响应类分别是<code>Request</code>和<code>Response</code>。请求类包含了URL、请求方法、请求头和请求体。响应类包含了响应码、响应头和响应体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javaRequest request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/getData&quot;)</span><br><span class="line">        .header(&quot;Authorization&quot;, &quot;Bearer token&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">int statusCode = response.code();</span><br><span class="line">String responseBody = response.body().string();</span><br></pre></td></tr></table></figure><h2 id="常见功能"><a href="#常见功能" class="headerlink" title="常见功能"></a>常见功能</h2><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>可以通过<code>Request.Builder</code>来添加请求头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaRequest request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/getData&quot;)</span><br><span class="line">        .addHeader(&quot;Authorization&quot;, &quot;Bearer token&quot;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>对于POST请求，可以使用<code>RequestBody</code>来设置请求体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javaRequestBody body = new FormBody.Builder()</span><br><span class="line">        .add(&quot;username&quot;, &quot;user&quot;)</span><br><span class="line">        .add(&quot;password&quot;, &quot;pass&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.example.com/login&quot;)</span><br><span class="line">        .post(body)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器可以在请求和响应过程中进行额外的处理，例如添加公共参数、记录日志等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaOkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">        .addInterceptor(new Interceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">                Request request = chain.request().newBuilder()</span><br><span class="line">                        .addHeader(&quot;Authorization&quot;, &quot;Bearer token&quot;)</span><br><span class="line">                        .build();</span><br><span class="line">                return chain.proceed(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>OKHttp支持响应缓存，可以通过设置缓存目录和大小来启用缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCache cache = new Cache(new File(&quot;cacheDirectory&quot;), 10 * 1024 * 1024); // 10 MB</span><br><span class="line"></span><br><span class="line">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">        .cache(cache)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>可以设置连接超时、读取超时和写入超时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaOkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(30, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(15, TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>OKHttp会自动管理连接池，重用连接以减少延迟。可以通过配置连接池大小和保持时间来优化性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaConnectionPool pool = new ConnectionPool(5, 5, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">        .connectionPool(pool)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>OKHttp支持WebSocket，可以通过<code>newWebSocket</code>方法来建立WebSocket连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javaRequest request = new Request.Builder()</span><br><span class="line">        .url(&quot;wss://echo.websocket.org&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">WebSocketListener listener = new WebSocketListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onOpen(WebSocket webSocket, Response response) &#123;</span><br><span class="line">        webSocket.send(&quot;Hello, WebSocket!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMessage(WebSocket webSocket, String text) &#123;</span><br><span class="line">        System.out.println(&quot;Received: &quot; + text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(WebSocket webSocket, Throwable t, Response response) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OkHttpClient client = new OkHttpClient();</span><br><span class="line">WebSocket webSocket = client.newWebSocket(request, listener);</span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">javapublic class OkHttpExample &#123;</span><br><span class="line">    private final OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">    public void run() throws Exception &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(&quot;https://api.example.com/getData&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        client.newCall(request).enqueue(new Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call call, Response response) throws IOException &#123;</span><br><span class="line">                if (response.isSuccessful()) &#123;</span><br><span class="line">                    System.out.println(response.body().string());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.err.println(&quot;Request failed: &quot; + response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new OkHttpExample().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OKHttp是一个功能强大且灵活的HTTP客户端库，适用于各种网络请求场景。它提供了便捷的API来处理同步和异步请求，支持丰富的功能如拦截器、缓存、超时设置和WebSocket。通过本文的介绍，读者应该能够熟练掌握OKHttp的基本用法和高级特性，并在实际项目中应用它们来构建高效的网络应用。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> okhttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令</title>
      <link href="/blog/2018/11/18/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2018/11/18/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常用的Git操作命令</p></blockquote><ul><li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a></li><li>配置文件<ul><li><a href="#%E6%9F%A5%E7%9C%8Bconfig">查看config</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">设置用户信息</a></li><li><a href="#git%E5%88%AB%E5%90%8D">Git别名</a></li><li><a href="#gitignore%E6%96%87%E4%BB%B6">.gitignore文件</a></li></ul></li><li>仓库的基础操作<ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93">初始化仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA">添加文件到暂存区</a></li><li><a href="#status%E4%BB%93%E5%BA%93">status仓库</a></li><li><a href="#diff%E4%BB%93%E5%BA%93">diff仓库</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">提交更新</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">移除文件</a></li><li><a href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">移动文件</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4">查看历史提交</a></li><li><a href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C">撤销操作</a></li><li><a href="#%E6%A0%87%E7%AD%BE">标签</a></li></ul></li><li>分支操作<ul><li><a href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA">分支的创建</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%88%87%E6%8D%A2">分支的切换</a></li><li><a href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">分支合并</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li><li><a href="#%E5%8F%98%E5%9F%BA">变基</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">远程分支</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF">跟踪分支</a></li></ul></li><li>远程仓库操作<ul><li><a href="#%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93">克隆仓库</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">查看远程仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">添加远程仓库</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%8B%89%E5%8F%96%E6%8E%A8%E9%80%81">远程仓库的拉取推送</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%A7%BB%E9%99%A4%E9%87%8D%E5%91%BD%E5%90%8D">远程仓库移除重命名</a></li></ul></li></ul><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><strong>Linux</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p><strong>Mac</strong></p><p>直接在<code>Terminal</code>执行<code>git</code>命令, 如果没有会提示安装方法.</p><p>如果喜欢安装程序的话, <a href="http://git-scm.com/download/mac">点这里</a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>第一次安装, 千万别要忘了配置你的git的使用者名字和邮箱. 这个道理很简单, 每一次的提交时需要记录提交者的, 如果没有提交者, 那么bug出现找谁来背锅??</p><h3 id="查看config"><a href="#查看config" class="headerlink" title="查看config"></a>查看config</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。</p><p><strong><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system --list</span><br></pre></td></tr></table></figure><hr><p><strong><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --list</span><br></pre></td></tr></table></figure><hr><p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p><p>每一个级别覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p><hr><p><strong>当然, 也可以查看某一项配置信息.</strong></p><ul><li>形式:<code>git config [--global|--system] &lt;key&gt;</code></li></ul><p><em>查看最终的配置属性值</em> <code>$ git config user.name</code></p><p><em>查看当前系统的属性值</em> <code>$ git config --global user.name</code></p><hr><h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;name&quot;</span><br><span class="line">$ git config --global user.email xxx@163.com</span><br></pre></td></tr></table></figure><p>使用<code>--global</code>选项, 当以后在该系统上做的任何操作都会使用此属性. 如果你需要在某一个特定的项目使用其他名字和邮箱, 那么可以通过设置<strong>项目中的config文件</strong>, 这样config中的属性会覆盖掉<strong>global的全局属性</strong>, 并且当在其他项目中并不会造成影响. 使用方式只需要去掉<code>--global</code>参数即可修改项目中的<code>.git/config</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name &quot;name&quot;</span><br></pre></td></tr></table></figure><hr><p><strong>获取帮助手册</strong></p><p>形式: <code>git help &lt;verb&gt;</code> 或者 <code>git &lt;verb&gt; --help</code></p><p>比如查看config手册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure><h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>例如: 生成别名之后可以在日后用简短的表示来使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>对于自动生成的文件, 日志, 编译的临时文件等. 可以对其进行配置, 让git不追踪这些文件</p><p>规范如下:</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（&#x2F;）开头防止递归。</li><li>匹配模式可以以（&#x2F;）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li></ul><p><code>glob模式</code>是指shell所使用的简化了的正则表达式.</p><ul><li><code>*</code> :匹配零个或多个任意字符</li><li><code>[abc]</code> :只匹配括号内的任意一个字符</li><li><code>[0-9]</code> :使用短划线表示范围, 可以匹配0到9之间的任何字符.</li><li><code>?</code> :匹配任意一个字符</li><li><code>**</code>:匹配任意的中间目录,例如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>等</li></ul><p>如下给出一个样板:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有以 .c结尾的文件</span><br><span class="line">*.c</span><br><span class="line"></span><br><span class="line"># 但是 stream.c 会被git追踪</span><br><span class="line">!stream.c</span><br><span class="line"></span><br><span class="line"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略所有在build文件夹下的文件</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略所有在doc目录下的.pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h2 id="仓库的基础操作"><a href="#仓库的基础操作" class="headerlink" title="仓库的基础操作"></a>仓库的基础操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加全部暂存区和历史区不存在的或者有更改的 `.c`结尾的文件</span><br><span class="line">$ git add *.c</span><br><span class="line"></span><br><span class="line"># 添加全部暂存区和历史区不存在的或者有更改的文件</span><br><span class="line">$ git add .  </span><br><span class="line"></span><br><span class="line"># 指定文件添加</span><br><span class="line">$ git add test.c</span><br></pre></td></tr></table></figure><hr><h3 id="status仓库"><a href="#status仓库" class="headerlink" title="status仓库"></a>status仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 如果需要显示一种紧凑式格式</span><br><span class="line">$ git status --short      # 等价于 $ git status -s</span><br></pre></td></tr></table></figure><p>紧凑式中字母的表示含义如下:</p><ul><li><code>??</code> :表示新添加的未追踪的文件</li><li><code> M</code> :M出现在右边,表示该文件被修改但是还没有放入暂存区</li><li><code>M </code> :M出现在左边,表示文件被修改已经放入了暂存区</li><li><code>MM</code> :出现两个,代表此文件在工作区修改已经放入了暂存区, 但之后有进行了修改,没有添加到暂存区</li></ul><hr><h3 id="diff仓库"><a href="#diff仓库" class="headerlink" title="diff仓库"></a>diff仓库</h3><p>如果你想知道文件具体修改的内容, 那么<code>diff</code>会很有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看以追踪但尚未暂存的文件更新了哪些部分, 不添加额外参数</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 对使用了add添加到了暂存区的内容, 使用--staged参数或者--cached</span><br><span class="line">$ git diff --staged</span><br></pre></td></tr></table></figure><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 常规做法</span><br><span class="line">$ git commit -m &quot;commit message&quot;</span><br><span class="line"></span><br><span class="line"># 如果不使用-m参数添加提交信息, git会使用默认的编译器如vi进行提交描述编写.</span><br><span class="line"># 可通过$ git config --global core.edit 设定喜欢的编译器</span><br><span class="line"></span><br><span class="line"># 跳过暂存区操作, 直接从工作区提交到历史区</span><br><span class="line">$ git commit -a -m &quot;&quot;          #等价于: $ git commit -am &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>如果在工作区间对一个文件进行删除, 需要先进行<code>add</code>,然后才可以提交. 使用<code>git rm</code>可以直接在工作区间删除文件, 并提交到暂存区.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm fileName</span><br><span class="line"></span><br><span class="line"># 如果文件修改,并添加了暂存区, 需要使用-f参数来强制删除(force)</span><br><span class="line">$ git rm -f fileName</span><br><span class="line"></span><br><span class="line"># 可以使用glob模式,如下</span><br><span class="line">$ git rm log/\*.log         # 删除log目录下所有名称是.log结尾文件</span><br><span class="line">$ git rm \*~                # 删除以~结尾的所有文件</span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>同样使用<code>git rm</code>会方便很多, 并且如果相对文件重命名也可以如此</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>当执行了这条语句之后, 只需要在下一次<code>commit</code>即可, 不需要考虑额外操作. 等价于如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv file_from file_to</span><br><span class="line">$ git rm file_from</span><br><span class="line">$ git rm file_to</span><br></pre></td></tr></table></figure><h3 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h3><p>如果是最基本的<code>git log</code>, 那么会按提交时间列出所有更新, 包括提交的SHA-1校验和, 作者名称,邮箱,提交时间,提交说明. 下面说说常用选项.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -p:仅显示最近x次的提交  格式 $ git log -p -x</span><br><span class="line">$ git log -p -2             # 查看最近的两次提交内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># --stat:简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># --pretty: 指定默认不同格式展示信息</span><br><span class="line">$ git log --pretty=oneline              #每次提交用一行显示</span><br><span class="line"></span><br><span class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;  </span><br><span class="line"># 效果:1a99c42 - 苏, 19 hours ago : 无意义提交</span><br></pre></td></tr></table></figure><p><strong>关于<code>format</code>对应的常用占位符的写法和意义</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 –date&#x3D; 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><hr><p><strong>图形展示分支的合并历史</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --oneline   #oneline只是让输出看起来比较舒服</span><br></pre></td></tr></table></figure><hr><p><strong>git log的一些其他操作</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td>–stat</td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td>–name-only</td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td>–name-status</td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td>–abbrev-commit</td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td>–relative-date</td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td>–graph</td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td>–pretty</td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p><strong>查找一个字符串的出现和删除的提交</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用限制符-S后面紧跟要查询的字符串</span><br><span class="line">$ git log -Smethod_name</span><br><span class="line"></span><br><span class="line"># 或者针对一个文件进行更改的提交查询, 只需要在后面追加文件名称即可</span><br><span class="line">$ git log fileName</span><br></pre></td></tr></table></figure><p>哈哈,即使如果你不小心写个隐藏bug不管几个月之后,如果老大要想找出问题是写引发的其实很简单.例如这样 <code>$ git log -p fileName</code> 想甩锅?算了吧,还是认错以后多注意吧.</p><p><strong>还有一些限制log输出的选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-(n)</td><td>仅显示最近的 n 条提交</td></tr><tr><td>–since, –after</td><td>仅显示指定时间之后的提交。</td></tr><tr><td>–until, –before</td><td>仅显示指定时间之前的提交。</td></tr><tr><td>–author</td><td>仅显示指定作者相关的提交。</td></tr><tr><td>–committer</td><td>仅显示指定提交者相关的提交。</td></tr><tr><td>–grep</td><td>仅显示含指定关键字的提交</td></tr><tr><td>-S</td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><p>一个实际的例子，如果要查看 Git 仓库中，2016 年 11 月1号到7号，作者叫苏的提交文件，可以用下面的查询命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&quot;%h - %s&quot; --author=苏 --since=&quot;2016-11-01&quot; \</span><br><span class="line">   --before=&quot;2016-11-07&quot;</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>amend重新提交</strong></p><p>当我们<code>commit</code>之后突然发现漏掉了一个文件, 这个时候不可能对一个文件再进行<code>commit</code>一次, 这样做就显得很多余, 而如果版本回退之前再添加也比较麻烦. 这个时候就可以使用这个<code>amend</code>命令.如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;版本1.5开发代码&quot;</span><br><span class="line"></span><br><span class="line"># 正当你松了一口气的时候发现配置文件忘记修改了, 你赶紧修改,并适合用add到暂存区</span><br><span class="line">$ git add project.property</span><br><span class="line">$ git commit --amend         </span><br><span class="line"># 你会神奇的发现你没有增加任何多余的操作就把漏掉的文件补齐到最后一次提交中</span><br></pre></td></tr></table></figure><hr><p><strong>取消暂存的文件</strong></p><p>就是对文件进行了<code>git add</code>操作. 这个时候可以<code>reset</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 让暂存区的文件变成文件修改但是没有添加暂存区的状态</span><br><span class="line">$ git reset HEAD fileName</span><br></pre></td></tr></table></figure><p><strong>撤销对文件的修改</strong></p><p>场景: 当文件修改了, 但是还没有进行<code>git add</code>的时候还只是在工作区间, 还原成最后一次提交的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- filename</span><br></pre></td></tr></table></figure><p>要注意使用, 使用之前确定是否要抛弃已经添加的内容. 因为这个动作可能让你最新添加的内容彻底丢失. 因为没有进行<code>commit</code>, 一般来说进行了<code>commit</code>的内容都是可以恢复的.</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote><p>Git可以给历史中的某一个提交打上标签, 以示重要. 比如每次正式版本的上线等.</p></blockquote><p><strong>列出标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 如果你只关心某一部分的标签, 例如只对v2.x的标签感兴趣,你可以这样做</span><br><span class="line">$ git tag -l &#x27;v2.*&#x27;</span><br></pre></td></tr></table></figure><hr><p><strong>创建标签</strong></p><p>标签分为两种一种是<code>附加标签</code>另一种是<code>轻量标签</code>.</p><ul><li>附加标签: 会保存打标签者的信息, 时间和附加信息. 最后更随打标签的提交</li><li>轻量标签: 只是在一个提交上做一个标记. 存储在一个专门保存标签的文件,指向提交的hash值</li></ul><p>先来看附加标签:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 -m &#x27;附加信息&#x27;</span><br></pre></td></tr></table></figure><p>轻量标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>后期打标签, 就是对已经提交某次提交进行追加标签设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以先使用git log --oneline获取提交历史的hash值</span><br><span class="line">$ git log --oneline</span><br><span class="line"></span><br><span class="line"># 然后把hash值赋值到标签语句之后</span><br><span class="line">$ git tag -a v1.1 a6b4c97</span><br></pre></td></tr></table></figure><p><strong>共享标签</strong></p><p>默认情况下, <code>git push</code>不会把标签传递到远程服务器. 需要显示的推送标签共享到服务器 例如: <code>git push origin [tagname]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.4</span><br><span class="line"></span><br><span class="line"># 如果想把本地上所有在远程服务器上的不存在标签删除掉,可以这样</span><br><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><hr><p><strong>检出标签</strong></p><p>git中不能真正的检出一个标签, 但是可以在标签处创建一个新的分支.如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b checkbranch2 v2.0</span><br></pre></td></tr></table></figure><hr><p><strong>查看标签对应的信息</strong></p><p>使用<code>git show &lt;标签名&gt;</code>可以查看对应标签的详细信息, 如果<code>git show</code>这样的命令只是显示上次提交的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h3><p>分支的创建, 其实本质就是创建一个可以移动的指针,这个指针名就是新的分支名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line"></span><br><span class="line"># 上面的只是创建了一个分支. 并没有切换, 可以使用一条命令创建并且换到新分支</span><br><span class="line">$ git checkout -b dev</span><br><span class="line"></span><br><span class="line"># 可以通过`git log`命令查看各个分支所指向的对象</span><br><span class="line">$ git log --oneline --decorate</span><br><span class="line"></span><br><span class="line"># 如果你想查看图形式的分叉历史,可以这样:</span><br><span class="line">$ git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure><h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>所谓的分支切换就是<code>HEAD</code>指针的指向的改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>利用<code>git merge &lt;要合并到的目标分支&gt;</code>, 这条命令会把当前所在分支与目标分支的内容合并, 可以这样理解, 如果当你试图向目标分支合并时, 如果当前分支可以顺着一个分支走下去, 那么本质上其实只是当前指针的向前移动, 由于这种情况下的合并并没有需要解决的分期, 所以git会称这个是<code>fast-forward</code>快速前进.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个功能分支开发完毕之后, 并进行了合并, 通常这个分支也就被删除,以保证仓库中的干净.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除dev分支</span><br><span class="line">$ git branch -d dev</span><br><span class="line"></span><br><span class="line"># 如果dev分支还有未提交的内容,为了保证你的数据安全git默认是不允许删除,可以使用`-D`强制删除</span><br><span class="line">$ git branch -D dev</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>命令不只是可以创建于删除分支. 如果不添加任何参数, 那么会得到所有分支的一个列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch        # 其中一个分支前面的*代表,目前检出的分支就是HEAD指针所指向的分支</span><br><span class="line"></span><br><span class="line"># 追加-v参数 可以展示每一个分支最后一次提交</span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"># --merged:查看那些分支已经合并到当前分支</span><br><span class="line">$ git branch --merged        # 一般这个列表展示的除了*号的其他分支, 都可以删除</span><br><span class="line"></span><br><span class="line"># --no-merged:查看所有包含未合并工作的分支</span><br><span class="line">$ git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><blockquote><p>和合并<code>merge</code>相似的效果都是合并分支, 但是使用变基<code>rebase</code>可以让提交历史变得更简洁. 如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># rebase &lt;目标分支名&gt; [需要移动变基底的分支]</span><br><span class="line">$ git rebase master experiment</span><br><span class="line"></span><br><span class="line"># 此时目标分支后面会追加另一个分支的提交. 此时只需要切换到master分支,合并分支即可.</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure><p><code>rebase</code>原理就是, 从目标分支和要变基的分支向上查找出共同祖先节点就是<code>c2</code>, 然后把要变基的分支到<code>c2</code>节点的所有提交,提取出相应的修改生成一个副本, 并追加到目标分创建相对应的提交. 此时变基的分支指向<code>目标分支master</code>的后面某一次提交. 此时只要使用修改<code>master</code>指向指针使用<code>merge</code>即可.</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获得远程的仓库列表</span><br><span class="line">$ git ls-remote origin</span><br><span class="line"></span><br><span class="line"># 如果想获得更多的信息</span><br><span class="line">$ git remote show origin</span><br><span class="line"></span><br><span class="line"># 查看远程分支和本地分支</span><br><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure><hr><p><strong>拉取远程分支</strong></p><p>假设远程如果有一个<code>dev</code>分支, 你使用<code>fetch</code>进行抓取. 这个时候, 本地不会自动生成一个可编辑的副本, 换句话说就是这种情况下, 不会有一个新的<code>dev</code>本地分支, 只有一个不可以修改的<code>origin/dev</code>指针. 这个时候可以运行<code>git merge origin/dev</code>命令, 将这些远程dev分支的工作合并到当前分支. 如果想要在自己本地的dev分支上工作, 可以将其建立在远程分支之上.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><hr><p><strong>创建远程分支</strong></p><p>如果你的本地有一个新建的<code>dev</code>分支, 并且你进行了提交, 此时你想把这个分支也提交到远程的<code>dev</code>分支, 但是远程还没有创建<code>dev</code>, 这个时候可以使用如下命令: <code>git push &lt;远程仓库名&gt; &lt;要推送的本地分支&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><hr><p><strong>删除远程分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除远程dev分支</span><br><span class="line">$ git push origin --delete dev</span><br></pre></td></tr></table></figure><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 <code>跟踪分支</code>（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入<code> git pull</code>，<code>Git</code> 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。 最简单的就是之前看到的例子，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/dev</span><br><span class="line"></span><br><span class="line"># 如果想要自定义本地分支名字</span><br><span class="line">$ git checkout -b 任意分支名字 origin/dev</span><br></pre></td></tr></table></figure><hr><p><strong>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支</strong>，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置HEAD指向的分支的上游为远程dev分支</span><br><span class="line">$ git branch -u origin/dev</span><br></pre></td></tr></table></figure><hr><p><strong>查看设置的所有跟踪分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br></pre></td></tr></table></figure><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt;</span><br><span class="line"></span><br><span class="line"># 如果你想创建自己的仓库名, 就是本地根文件夹的名称, 那么可以如下追加名称</span><br><span class="line">$ git clone &lt;url&gt; [dirName]</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认查看远程仓库的方式</span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"># 查看远程仓库的读写权限. 如果可以看到(push)说明提交的推送</span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>如果需要查看某一个仓库更多的信息时, 使用<code>git remote show ...</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 格式: git remote add [shortName] &lt;url&gt;  同时可以指定一个仓库的引用名称,例如</span><br><span class="line">$ git remote add rp git@github.com:suzeyu1992/GitOperateDemo.git</span><br><span class="line"></span><br><span class="line"># 此时你想对新加的远程进行拉取动作, 只需要使用之前的引用名称就可以</span><br><span class="line">$ git fetch rp</span><br></pre></td></tr></table></figure><h3 id="远程仓库的拉取推送"><a href="#远程仓库的拉取推送" class="headerlink" title="远程仓库的拉取推送"></a>远程仓库的拉取推送</h3><p><strong>拉取</strong></p><p>大家常用的可能是<code>git pull</code>这个指令. 这个指令的通常会从服务器上抓取数据自动尝试合并到当前所在分支.</p><p>而我们可以也可以利用<code>git fetch </code>进行本地分支所追踪的远程分支没有提交. 然后我们可以手动的进行合并.</p><p><strong>推送</strong></p><p><code>git push [remote-name] [branch-name]</code> 例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当对服务器有写入权限, 并且之前没有人提交, 这条命令才会生效.</p><p>上面的这两个推送也好拉取也好. 如果所在分支设置了远程服务器分支的追踪, 那么可以省略掉后面的仓库名和分支名. 如果没有设置那么必须显示的指定.</p><h3 id="远程仓库移除重命名"><a href="#远程仓库移除重命名" class="headerlink" title="远程仓库移除重命名"></a>远程仓库移除重命名</h3><p>对远程仓库的名称进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename oldName newName</span><br></pre></td></tr></table></figure><p>想要移除一个远程仓库,例如服务器搬走了,不再使用一个特定镜像,或者一个贡献者不再贡献</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm 仓库名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http1.0 vs Http2.0对比</title>
      <link href="/blog/2018/04/07/Http1-0-vs-Http2-0/"/>
      <url>/blog/2018/04/07/Http1-0-vs-Http2-0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-1-0-vs-HTTP-2-0-详细对比"><a href="#HTTP-1-0-vs-HTTP-2-0-详细对比" class="headerlink" title="HTTP 1.0 vs HTTP 2.0: 详细对比"></a>HTTP 1.0 vs HTTP 2.0: 详细对比</h1><p>HTTP（超文本传输协议）是万维网数据通信的基础。自从1991年发布以来，HTTP经历了多次改进和更新，HTTP&#x2F;1.0和HTTP&#x2F;2.0是两个重要的版本。本文将详细对比HTTP&#x2F;1.0和HTTP&#x2F;2.0的区别，帮助读者更好地理解它们的特性和应用场景。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0">基础概述</a></li><li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a></li><li><a href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94">请求和响应</a></li><li><a href="#%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9">头部压缩</a></li><li><a href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li><li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">服务器推送</a></li><li><a href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E6%AF%94">实例对比</a></li><li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li></ol><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><ul><li>发布于1996年</li><li>每次请求都需要建立一个新的TCP连接</li><li>不支持持久连接</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><ul><li>发布于2015年</li><li>基于SPDY协议（由Google开发）</li><li>支持持久连接和多路复用</li></ul><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="HTTP-1-0-1"><a href="#HTTP-1-0-1" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>在HTTP&#x2F;1.0中，每个请求&#x2F;响应对需要单独的TCP连接。这意味着，如果一个网页包含多个资源（如图片、CSS文件和JavaScript文件），浏览器必须为每个资源建立一个新的连接。这种方式效率低下，增加了网络延迟和服务器负载。</p><h3 id="HTTP-2-0-1"><a href="#HTTP-2-0-1" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2.0使用单个持久的TCP连接处理多个请求&#x2F;响应对。这大大减少了连接建立的开销，降低了延迟，提升了性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plaintextHTTP/1.0: Connection per request</span><br><span class="line">Client -&gt; Server : Request 1 (Connection 1)</span><br><span class="line">Client -&gt; Server : Request 2 (Connection 2)</span><br><span class="line">Client -&gt; Server : Request 3 (Connection 3)</span><br><span class="line"></span><br><span class="line">HTTP/2.0: Single connection for multiple requests</span><br><span class="line">Client -&gt; Server : Request 1, Request 2, Request 3 (Connection 1)</span><br></pre></td></tr></table></figure><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><h3 id="HTTP-1-0-2"><a href="#HTTP-1-0-2" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>每个请求&#x2F;响应对都是独立的，浏览器需要等待前一个请求完成才能发送下一个请求。这种线性的处理方式导致了“队头阻塞”问题。</p><h3 id="HTTP-2-0-2"><a href="#HTTP-2-0-2" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2.0支持多路复用，允许多个请求&#x2F;响应在一个连接中并发进行，解决了队头阻塞问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plaintextHTTP/1.0: Sequential request/response</span><br><span class="line">Client -&gt; Server : Request 1</span><br><span class="line">Client &lt;- Server : Response 1</span><br><span class="line">Client -&gt; Server : Request 2</span><br><span class="line">Client &lt;- Server : Response 2</span><br><span class="line"></span><br><span class="line">HTTP/2.0: Concurrent request/response</span><br><span class="line">Client -&gt; Server : Request 1, Request 2</span><br><span class="line">Client &lt;- Server : Response 1, Response 2</span><br></pre></td></tr></table></figure><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><h3 id="HTTP-1-0-3"><a href="#HTTP-1-0-3" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>HTTP&#x2F;1.0不支持头部压缩，每个请求都需要发送完整的头部信息，增加了网络带宽消耗。</p><h3 id="HTTP-2-0-3"><a href="#HTTP-2-0-3" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>HTTP&#x2F;2.0引入了HPACK头部压缩机制，通过压缩头部信息减少了带宽使用，提高了传输效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plaintextHTTP/1.0: Uncompressed headers</span><br><span class="line">GET /index.html HTTP/1.0</span><br><span class="line">Host: example.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line"></span><br><span class="line">HTTP/2.0: Compressed headers</span><br><span class="line">GET /index.html HTTP/2.0</span><br><span class="line">(Headers compressed using HPACK)</span><br></pre></td></tr></table></figure><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h3 id="HTTP-1-0-4"><a href="#HTTP-1-0-4" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>每个请求&#x2F;响应对占用一个连接，不能同时处理多个请求。</p><h3 id="HTTP-2-0-4"><a href="#HTTP-2-0-4" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>在一个TCP连接上同时处理多个请求和响应，极大地提高了传输效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plaintextHTTP/1.0: Single request per connection</span><br><span class="line">Client -&gt; Server : Request 1</span><br><span class="line">Client &lt;- Server : Response 1</span><br><span class="line"></span><br><span class="line">HTTP/2.0: Multiple requests per connection</span><br><span class="line">Client -&gt; Server : Request 1, Request 2</span><br><span class="line">Client &lt;- Server : Response 1, Response 2</span><br></pre></td></tr></table></figure><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="HTTP-1-0-5"><a href="#HTTP-1-0-5" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>没有内置的流量控制机制。</p><h3 id="HTTP-2-0-5"><a href="#HTTP-2-0-5" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>引入了流量控制机制，允许客户端和服务器控制数据传输的速率，防止网络拥塞。</p><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><h3 id="HTTP-1-0-6"><a href="#HTTP-1-0-6" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>不支持服务器推送。</p><h3 id="HTTP-2-0-6"><a href="#HTTP-2-0-6" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><p>支持服务器推送功能，服务器可以主动向客户端推送资源，减少了延迟。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plaintextHTTP/2.0: Server Push</span><br><span class="line">Client -&gt; Server : Request /index.html</span><br><span class="line">Server -&gt; Client : Response /index.html, Push /style.css, Push /script.js</span><br></pre></td></tr></table></figure><h2 id="实例对比"><a href="#实例对比" class="headerlink" title="实例对比"></a>实例对比</h2><h3 id="HTTP-1-0实例"><a href="#HTTP-1-0实例" class="headerlink" title="HTTP&#x2F;1.0实例"></a>HTTP&#x2F;1.0实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plaintextGET /index.html HTTP/1.0</span><br><span class="line">Host: example.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line"></span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1024</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="HTTP-2-0实例"><a href="#HTTP-2-0实例" class="headerlink" title="HTTP&#x2F;2.0实例"></a>HTTP&#x2F;2.0实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plaintext:method = GET</span><br><span class="line">:path = /index.html</span><br><span class="line">:scheme = https</span><br><span class="line">:authority = example.com</span><br><span class="line"></span><br><span class="line">HTTP/2.0 200</span><br><span class="line">content-type: text/html</span><br><span class="line">content-length: 1024</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>HTTP&#x2F;2.0相对于HTTP&#x2F;1.0在多个方面进行了改进，特别是在连接管理、请求和响应处理、头部压缩、多路复用、流量控制和服务器推送等方面。通过这些改进，HTTP&#x2F;2.0大幅提升了传输效率和性能，减少了延迟，改善了用户体验。理解这两者之间的区别，有助于我们在实际应用中更好地选择和优化网络协议。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用配置及常见问题</title>
      <link href="/blog/2018/02/01/Git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2018/02/01/Git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="在-Ubuntu-上配置-SSH-和-Git-以便与-GitHub-进行交互的完整步骤如下："><a href="#在-Ubuntu-上配置-SSH-和-Git-以便与-GitHub-进行交互的完整步骤如下：" class="headerlink" title="在 Ubuntu 上配置 SSH 和 Git 以便与 GitHub 进行交互的完整步骤如下："></a>在 Ubuntu 上配置 SSH 和 Git 以便与 GitHub 进行交互的完整步骤如下：</h3><h3 id="1-检查是否已安装-Git"><a href="#1-检查是否已安装-Git" class="headerlink" title="1. 检查是否已安装 Git"></a>1. 检查是否已安装 Git</h3><p>首先，确保你的系统上已经安装了 Git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><p>如果没有安装 Git，可以通过以下命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashsudo apt update</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h3 id="2-生成-SSH-密钥"><a href="#2-生成-SSH-密钥" class="headerlink" title="2. 生成 SSH 密钥"></a>2. 生成 SSH 密钥</h3><ol><li>生成新的 SSH 密钥：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果你使用的是旧版本的 OpenSSH（7.8 之前），可以使用 <code>rsa</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><ol><li>当提示你输入文件保存位置时，按下 Enter 键以接受默认位置：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vbnetGenerating public/private ed25519 key pair.</span><br><span class="line">Enter file in which to save the key (/home/your_username/.ssh/id_ed25519):</span><br></pre></td></tr></table></figure><ol><li>输入一个安全的密码短语（或留空）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graphqlEnter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><h3 id="3-添加-SSH-密钥到-ssh-agent"><a href="#3-添加-SSH-密钥到-ssh-agent" class="headerlink" title="3. 添加 SSH 密钥到 ssh-agent"></a>3. 添加 SSH 密钥到 ssh-agent</h3><ol><li>启动 ssh-agent：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure><ol><li>将 SSH 私钥添加到 ssh-agent：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure><h3 id="4-添加-SSH-公钥到-GitHub"><a href="#4-添加-SSH-公钥到-GitHub" class="headerlink" title="4. 添加 SSH 公钥到 GitHub"></a>4. 添加 SSH 公钥到 GitHub</h3><ol><li>复制你的 SSH 公钥到剪贴板：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure><ol><li>登录到 <a href="https://github.com/">GitHub</a>。</li><li>点击右上角的头像，然后点击 <strong>Settings</strong>。</li><li>在左侧菜单中，点击 <strong>SSH and GPG keys</strong>。</li><li>点击 <strong>New SSH key</strong>。</li><li>将复制的公钥粘贴到 <strong>Key</strong> 字段中，并给密钥取一个名称，然后点击 <strong>Add SSH key</strong>。</li></ol><h3 id="5-配置-Git-用户信息"><a href="#5-配置-Git-用户信息" class="headerlink" title="5. 配置 Git 用户信息"></a>5. 配置 Git 用户信息</h3><ol><li>配置你的 Git 用户名：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure><ol><li>配置你的 Git 邮箱地址：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="6-验证-SSH-连接"><a href="#6-验证-SSH-连接" class="headerlink" title="6. 验证 SSH 连接"></a>6. 验证 SSH 连接</h3><p>使用以下命令来验证是否成功配置了 SSH 密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果配置成功，你应该会看到类似于以下内容的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vbnet</span><br><span class="line"></span><br><span class="line">Hi your_username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h3 id="7-克隆-GitHub-仓库"><a href="#7-克隆-GitHub-仓库" class="headerlink" title="7. 克隆 GitHub 仓库"></a>7. 克隆 GitHub 仓库</h3><p>现在，你可以使用 SSH 克隆 GitHub 仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git clone git@github.com:your_username/your_repository.git</span><br></pre></td></tr></table></figure><h3 id="8-推送到远程仓库"><a href="#8-推送到远程仓库" class="headerlink" title="8. 推送到远程仓库"></a>8. 推送到远程仓库</h3><ol><li>添加更改：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><ol><li>提交更改：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git commit -m &quot;Your commit message&quot;</span><br></pre></td></tr></table></figure><ol><li>推送到远程仓库：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>注意事项:</p><ul><li>确保在 GitHub 上正确设置了你的 SSH 公钥。</li><li>使用 SSH URL 进行 Git 操作，例如 <code>git@github.com:your_username/your_repository.git</code>。</li><li>使用合适的密码短语来保护你的 SSH 私钥。</li></ul><h3 id="9-Git设置取消代理"><a href="#9-Git设置取消代理" class="headerlink" title="9. Git设置取消代理"></a>9. Git设置取消代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><h3 id="10-Git碰到PAT检验失败-无法push"><a href="#10-Git碰到PAT检验失败-无法push" class="headerlink" title="10. Git碰到PAT检验失败,无法push"></a>10. Git碰到PAT检验失败,无法push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[remote rejected] (refusing to allow a Personal Access Token to create or update xxx)</span><br><span class="line">error: failed to push some refs to</span><br></pre></td></tr></table></figure><p>尝试以下步骤来解决排查:</p><ol><li><p>创建 PAT（个人访问令牌）：<a href="https://docs.github.com/en/enterprise-server@3.4/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">官方文档</a>。</p></li><li><p>然后在终端中，<br><code>git remote add origin https://github.com/&lt;account&gt;/&lt;repo&gt;.git</code></p><p>平时使用的这个方式来添加远程仓库地址,可以尝试以下:<br><code>git remote add origin https://&lt;PAT&gt;@github.com/&lt;account&gt;/&lt;repo&gt;.git</code></p><p>如果碰到远程仓库已经存在的提示,先删除:</p><p><code>get remote</code>查看当前的地址,然后<code>git remote rm origin</code></p></li><li><p>继续操作<code>git branch -M main</code>和<code>git push -u origin main</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
