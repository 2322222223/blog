<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github Actions私有仓库部署踩坑记</title>
      <link href="/blog/2023/06/01/Github-Actions%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
      <url>/blog/2023/06/01/Github-Actions%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><em>在使用 GitHub Actions 自动化部署 Hexo 博客的过程中，因为我是使用的私有仓库来存储blog源码,更新后需要将public自动提交到公共仓库中.</em></p><ol><li><h5 id="部署密钥和令牌问题"><a href="#部署密钥和令牌问题" class="headerlink" title="部署密钥和令牌问题:"></a>部署密钥和令牌问题:</h5><ul><li>GitHub Actions 默认的 GITHUB_TOKEN 不支持推送到外部仓库。这意味着当我们尝试将生成的站点文件从一个仓库推送到另一个仓库时，GITHUB_TOKEN 无法使用,(我这里是使用<code>peaceiris/actions-gh-pages@v3</code>来进行部署)。 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">        <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure> 接下来推送代码,部署过程中报错然后查看Workflow Deploy: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Action failed with <span class="string">&quot;The generated GITHUB_TOKEN (github_tokendoes not support to push to an external repository.</span></span><br><span class="line"><span class="string">Use deploy_key or personal_token.</span></span><br></pre></td></tr></table></figure> 原来GITHUB_TOKEN是不支持推送到外部仓库,只能在当前的仓库去执行操作,比如:如推送文件、修改 Issues 等。</li></ul><p> 那就去创建一个,接着:</p><ul><li><code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>Personal access tokens</code> -&gt; <code>Generate new token</code> -&gt; <code>勾选repo</code> -&gt; <code>Generate</code></li></ul><p> 然后把创建的PAT添加到Secrets:</p><ul><li><code>仓库页面</code> -&gt; <code>Settings</code> -&gt; <code>Secrets and variables</code> -&gt; <code>Actions</code> -&gt; <code>New repository secret</code> -&gt; <code>填写Name和生成的PAT</code></li></ul><p> OK,把这个名称填写到:</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRETS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p> 注: secrets.NAME不能使用GITHUB_开头。</p><p> 下面介绍一下支持的Tokens:</p><table><thead><tr><th>Token</th><th>Private repo</th><th>Public repo</th><th>Protocol</th><th>Setup</th></tr></thead><tbody><tr><td>github_token</td><td>✅️</td><td>✅️</td><td>HTTPS</td><td>Unnecessary</td></tr><tr><td>deploy_key</td><td>✅️</td><td>✅️</td><td>SSH</td><td>Necessary</td></tr><tr><td>personal_token</td><td>✅️</td><td>✅️</td><td>HTTPS</td><td>Necessary</td></tr></tbody></table><p> 实际上GITHUB_TOKEN是可以访问部署GitHub Pages的,但由于我们第一步部署需要选择或者创建GitHub Pages分支,通常为:<code>gh-pages</code>,第一次操作通常没有添加write权限,所以会报错:<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/git push origin gh-pages</span><br><span class="line">remote: Write access to repository not granted.</span><br><span class="line">fatal: unable to access &#x27;https://github.com/username/repository.git/&#x27;: The requested URL returned error: 403</span><br><span class="line">Error: Action failed with &quot;The process &#x27;/usr/bin/git&#x27; failed with exit code 128&quot;</span><br></pre></td></tr></table></figure></p></li><li><h5 id="SSH-私钥deploy-key限制"><a href="#SSH-私钥deploy-key限制" class="headerlink" title="SSH 私钥deploy_key限制:"></a>SSH 私钥deploy_key限制:</h5> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setup auth token</span><br><span class="line">Error: Action failed with &quot;not found deploy key or tokens&quot;</span><br></pre></td></tr></table></figure><ul><li>Secret中Aciton应该的对应的<code>personal_token</code>,主要作用是用于提交git-commit相关的一些操作。</li><li><code>deploy_key</code>应该通过Deploy keys应该是通过SSH生成的公钥。</li><li>同样SSH的私钥应该是在<code>Dependabot</code>中添加的,这样才能对应的上来。</li></ul><p> 具体的操作:</p><ol><li><p>生成部署的秘钥:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f gh-pages-deploy -N &quot;&quot; </span><br></pre></td></tr></table></figure><p> 生成两个文件:<code>gh-pages-deploy.pub</code>公钥,<code>gh-pages-deploy</code> 私钥,<br> 查看并复制</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat gh-pages-deploy</span><br><span class="line">cat gh-pages-deploy.pub</span><br></pre></td></tr></table></figure></li><li><p>然后转到Deploy Key添加公钥，勾选允许写入访问</p></li><li><p>最后转到<code>仓库页面</code> -&gt; <code>Settings</code> -&gt; <code>Secrets and variables</code> -&gt; <code>Actions</code> -&gt; <code>New repository secret</code> 添加私钥</p></li></ol><p> 最后:<br> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRETS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLIC_DEPLOY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><p>GitHub Actions 是一个强大的工具，可以帮助自动化 Hexo 博客的部署过程。然而，正确配置是成功部署的关键。通过以上讨论的问题和解决方案，我们可以更有效地管理和解决在自动化部署过程中可能遇到的挑战。</p><hr><p>这篇文章概述了与 GitHub Actions 相关的一些常见问题以及如何解决这些问题，希望能帮助你更好地使用这个强大的自动化工具。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> Github Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/blog/2023/02/18/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2023/02/18/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ol><li>保存命令</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker save -o name.tar image-name</span><br><span class="line"></span><br><span class="line">#压缩镜像</span><br><span class="line">gzip name.tar</span><br></pre></td></tr></table></figure></blockquote><ol><li>保存并直接压缩</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save image-name |gzip&gt;name.tar.gz</span><br></pre></td></tr></table></figure></blockquote><ol><li>build</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build -t image-name:tag -f Dockerfile .</span><br><span class="line"></span><br><span class="line">#根据当前的cpu架构来构建</span><br><span class="line">#docker build -t 172.18.0.40:82/ai/kubeflow-dashboard-frontend-enterprise:2023.12.28-amd64 -f install/docker/dockerFrontend/Dockerfile .</span><br><span class="line"></span><br><span class="line">#指定平台构建 可以选择amd64或arm64或者打包两个</span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t image-name:tag -f Dockerfile .  --push</span><br></pre></td></tr></table></figure></blockquote><ol><li>推送</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push image-name</span><br></pre></td></tr></table></figure></blockquote><ol><li>运行</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br><span class="line"></span><br><span class="line">#docker run -d -p 80:80 --name webserver nginx</span><br><span class="line">#使用 -d 参数在后台运行容器。-p 80:80 将容器的80端口映射到主机的80端口。--name webserver 给容器命名为 webserver。nginx 是要运行的镜像名称</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">#列出所有本地存储的镜像</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看容器</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">#列出当前运行的容器。</span><br><span class="line">#不带参数默认只显示运行中的容器。-a 参数显示所有容器，包括未运行</span><br></pre></td></tr></table></figure></blockquote><ol><li>停止</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br><span class="line">#停止一个或多个运行中的容器 docker stop webserver</span><br><span class="line">#停止所有: </span><br><span class="line">#docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure></blockquote><ol><li>删除容器</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br><span class="line">#删除一个或多个容器 docker rm webserver / docker rm -f webserver</span><br><span class="line">#删除所有:</span><br><span class="line">#docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure></blockquote><ol><li>删除镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi</span><br><span class="line">#删除一个或多个镜像 docker rmi webserver</span><br><span class="line">#删除所有:</span><br><span class="line">#docker rmi $(docker ps -aq)</span><br></pre></td></tr></table></figure></blockquote><ol><li>进入容器执行命令</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec</span><br><span class="line">#进入容器可以执行命令 docker exec -it webserver bash</span><br><span class="line">#docker exec -it mysql mysql -uroot -p</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看容器或镜像的详细信息</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect</span><br><span class="line">#docker inspect webserver </span><br><span class="line">#webserver 是容器或镜像的名称或 ID</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看log</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line">#获取容器列出的日志</span><br><span class="line">#docker logs webserver</span><br></pre></td></tr></table></figure></blockquote><ol><li>其他:</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#启动容器</span><br><span class="line">docker start</span><br><span class="line"></span><br><span class="line">#暂停进程</span><br><span class="line">docker pause</span><br><span class="line"></span><br><span class="line">#恢复容器</span><br><span class="line">docker unpause</span><br><span class="line"></span><br><span class="line">#重启容器</span><br><span class="line">docker restart</span><br><span class="line"></span><br><span class="line">#杀掉运行中的容器</span><br><span class="line">docker kill</span><br><span class="line"></span><br><span class="line">#开启docker </span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#查看docker状态</span><br><span class="line">systemctl status docker </span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">systemctl stop docker </span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line">systemctl  restart docker</span><br><span class="line"></span><br><span class="line">#设置开启自启</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></blockquote><ol><li>打标签</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag</span><br><span class="line">#给本地镜像打标签</span><br><span class="line">#docker tag myimage:tag username/repository:tag</span><br></pre></td></tr></table></figure></blockquote><ol><li>加载本地镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker load</span><br><span class="line">#加载tar本地镜像</span><br><span class="line">#docker load -i filename.tar</span><br></pre></td></tr></table></figure></blockquote><ol><li>查看历史记录</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker history</span><br><span class="line">#查看镜像的历史记录</span><br><span class="line">#docker history myimage:tag</span><br></pre></td></tr></table></figure></blockquote><ol><li>从容器中拷贝</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp container-name file-name</span><br></pre></td></tr></table></figure></blockquote><p>19.导出容器 另存为文件</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export -o file-name.tar container-name/container-id</span><br></pre></td></tr></table></figure></blockquote><p>20.从文件导入镜像</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import file-name.tar container-name:tag</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/blog/2022/10/18/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2022/10/18/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="基础常用命令"><a href="#基础常用命令" class="headerlink" title="基础常用命令"></a>基础常用命令</h2><ul><li><p><code>某个命令 --h</code>，对这个命令进行解释</p></li><li><p><code>某个命令 --help</code>，解释这个命令(更详细)</p></li><li><p><code>man某个命令</code>，文档式解释这个命令(更更详细)(执行该命令后,还可以按&#x2F;+关键字进行查询结果的搜索)</p></li><li><p><code>Ctrl + c</code>，结束命令</p></li><li><p><code>history</code>，查看所有的历史命令</p></li><li><p><code>Ctrl + r</code>，进入历史命令的搜索功能模式</p></li><li><p><code>clear</code>，清除屏幕里面的所有命令</p></li><li><p><code>pwd</code>，显示当前目录路径（常用）</p></li><li><p><code>firefox&amp;</code>，最后后面的 <strong>&amp;</strong> 符号，表示使用后台方式打开 Firefox，然后显示该进程的 PID 值</p></li><li><p><code>jobs</code>，查看后台运行的程序列表</p></li><li><p><code>ifconfig</code>，查看内网 IP 等信息（常用）</p></li><li><p><code>curl ifconfig.me</code>，查看外网 IP 信息</p></li><li><p><code>curl ip.cn</code>，查看外网 IP 信息</p></li><li><pre><code>locate 搜索关键字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，快速搜索系统文件/文件夹（类似 Windows 上的 everything 索引式搜索）（常用）</span><br><span class="line"></span><br><span class="line">  - `updatedb`，配合上面的 locate，给 locate 的索引更新（locate 默认是一天更新一次索引）（常用）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  date</span><br></pre></td></tr></table></figure>，查看系统时间（常用）- `date -s20080103`，设置日期（常用）- `date -s18:24`，设置时间，如果要同时更改 BIOS 时间，再执行 `hwclock --systohc`（常用）</code></pre></li><li><p><code>cal</code>，在终端中查看日历，肯定没有农历显示的</p></li><li><p><code>uptime</code>，查看系统已经运行了多久，当前有几个用户等信息（常用）</p></li><li><p><code>cat 文件路名</code>，显示文件内容（属于打印语句）</p></li><li><p><code>cat -n 文件名</code>，显示文件，并每一行内容都编号</p></li><li><p><code>more 文件名</code>，用分页的方式查看文件内容（按 space 翻下一页，按 <em>Ctrl + B</em> 返回上页）</p></li><li><pre><code>less<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  文件名，用分页的方式查看文件内容（带上下翻页）</span><br><span class="line"></span><br><span class="line">  - 按 **j** 向下移动，按 **k** 向上移动</span><br><span class="line">  - 按 **/** 后，输入要查找的字符串内容，可以对文件进行向下查询，如果存在多个结果可以按 **n** 调到下一个结果出</span><br><span class="line">  - 按 **？** 后，输入要查找的字符串内容，可以对文件进行向上查询，如果存在多个结果可以按 **n** 调到下一个结果出</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  shutdown</span><br></pre></td></tr></table></figure>- `shutdown -hnow`，立即关机- `shutdown -h+10`，10 分钟后关机- `shutdown -h23:30`，23:30 关机- `shutdown -rnew`，立即重启</code></pre></li><li><p><code>poweroff</code>，立即关机（常用）</p></li><li><p><code>reboot</code>，立即重启（常用）</p></li><li><pre><code>zip mytest.zip /opt/test/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，把 /opt 目录下的 test/ 目录进行压缩，压缩成一个名叫 mytest 的 zip 文件</span><br><span class="line"></span><br><span class="line">  - `unzip mytest.zip`，对 mytest.zip 这个文件进行解压，解压到当前所在目录</span><br><span class="line">  - `unzip mytest.zip -d /opt/setups/`，对 mytest.zip 这个文件进行解压，解压到 /opt/setups/ 目录下</span><br><span class="line"></span><br><span class="line">- `tar -cvf mytest.tar mytest/`，对 mytest/ 目录进行归档处理（归档和压缩不一样）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tar -xvf mytest.tar</span><br></pre></td></tr></table></figure>，释放 mytest.tar 这个归档文件，释放到当前目录- `tar -xvf mytest.tar -C /opt/setups/`，释放 mytest.tar 这个归档文件，释放到 /opt/setups/ 目录下</code></pre></li><li><p><code>last</code>，显示最近登录的帐户及时间</p></li><li><p><code>lastlog</code>，显示系统所有用户各自在最近登录的记录，如果没有登录过的用户会显示 <strong>从未登陆过</strong></p></li><li><pre><code>ls<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">，列出当前目录下的所有没有隐藏的文件 / 文件夹。</span><br><span class="line"></span><br><span class="line">- `ls -a`，列出包括以.号开头的隐藏文件 / 文件夹（也就是所有文件）</span><br><span class="line">- `ls -R`，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，不显示隐藏的文件）</span><br><span class="line">- `ls -a -R`，显示出目录下以及其所有子目录的文件 / 文件夹（递归地方式，显示隐藏的文件）</span><br><span class="line">- `ls -al`，列出目录下所有文件（包含隐藏）的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息）</span><br><span class="line">- `ls -ld 目录名`，显示该目录的基本信息</span><br><span class="line">- `ls -t`，依照文件最后修改时间的顺序列出文件名。</span><br><span class="line">- `ls -F`，列出当前目录下的文件名及其类型。以 **/** 结尾表示为目录名，以 ***** 结尾表示为可执行文件，以 **@** 结尾表示为符号连接</span><br><span class="line">- `ls -lg`，同上，并显示出文件的所有者工作组名。</span><br><span class="line">- `ls -lh`，查看文件夹类文件详细信息，文件大小，文件修改时间</span><br><span class="line">- `ls /opt | head -5`，显示 opt 目录下前 5 条记录</span><br><span class="line">- `ls -l | grep &#x27;.jar&#x27;`，查找当前目录下所有 jar 文件</span><br><span class="line">- `ls -l /opt |grep &quot;^-&quot;|wc -l`，统计 opt 目录下文件的个数，不会递归统计</span><br><span class="line">- `ls -lR /opt |grep &quot;^-&quot;|wc -l`，统计 opt 目录下文件的个数，会递归统计</span><br><span class="line">- `ls -l /opt |grep &quot;^d&quot;|wc -l`，统计 opt 目录下目录的个数，不会递归统计</span><br><span class="line">- `ls -lR /opt |grep &quot;^d&quot;|wc -l`，统计 opt 目录下目录的个数，会递归统计</span><br><span class="line">- `ls -lR /opt |grep &quot;js&quot;|wc -l`，统计 opt 目录下 js 文件的个数，会递归统计</span><br><span class="line">- `ls -l`，列出目录下所有文件的权限、所有者、文件大小、修改时间及名称（也就是显示详细信息，不显示隐藏文件）。显示出来的效果如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>-rwxr-xr-x. 1 root root 4096 3月 26 10:57，其中最前面的 - 表示这是一个普通文件lrwxrwxrwx. 1 root root 4096 3月 26 10:57，其中最前面的 l 表示这是一个链接文件，类似 Windows 的快捷方式drwxr-xr-x. 5 root root 4096 3月 26 10:57，其中最前面的 d 表示这是一个目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  cd</span><br></pre></td></tr></table></figure>，目录切换- `cd ..`，改变目录位置至当前目录的父目录(上级目录)。- `cd ~`，改变目录位置至用户登录时的工作目录。- `cd 回车`，回到家目录- `cd -`，上一个工作目录- `cd dir1/`，改变目录位置至 dir1 目录下。- `cd ~user`，改变目录位置至用户的工作目录。- `cd ../user`，改变目录位置至相对路径user的目录下。- `cd /../..`，改变目录位置至绝对路径的目录位置下。</code></pre></li><li><pre><code>cp 源文件 目标文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，复制文件</span><br><span class="line"></span><br><span class="line">  - `cp -r 源文件夹 目标文件夹`，复制文件夹</span><br><span class="line">  - `cp -r -v 源文件夹 目标文件夹`，复制文件夹(显示详细信息，一般用于文件夹很大，需要查看复制进度的时候)</span><br><span class="line">  - `cp /usr/share/easy-rsa/2.0/keys/&#123;ca.crt,server.&#123;crt,key&#125;,dh2048.pem,ta.key&#125; /etc/openvpn/keys/`，复制同目录下花括号中的文件</span><br><span class="line"></span><br><span class="line">- `tar cpf - . | tar xpf - -C /opt`，复制当前所有文件到 /opt 目录下，一般如果文件夹文件多的情况下用这个更好，用 cp 比较容易出问题</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  mv 文件 目标文件夹</span><br></pre></td></tr></table></figure>，移动文件到目标文件夹- `mv 文件`，不指定目录重命名后的名字，用来重命名文件</code></pre></li><li><p><code>touch 文件名</code>，创建一个空白文件&#x2F;更新已有文件的时间(后者少用)</p></li><li><p><code>mkdir 文件夹名</code>，创建文件夹</p></li><li><p><code>mkdir -p /opt/setups/nginx/conf/</code>，创建一个名为 conf 文件夹，如果它的上级目录 nginx 没有也会跟着一起生成，如果有则跳过</p></li><li><p><code>rmdir 文件夹名</code>，删除文件夹(只能删除文件夹里面是没有东西的文件夹)</p></li><li><pre><code>rm 文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，删除文件</span><br><span class="line"></span><br><span class="line">  - `rm -r 文件夹`，删除文件夹</span><br><span class="line">  - `rm -r -i 文件夹`，在删除文件夹里的文件会提示(要的话,在提示后面输入yes)</span><br><span class="line">  - `rm -r -f 文件夹`，强制删除</span><br><span class="line">  - `rm -r -f 文件夹1/ 文件夹2/ 文件夹3/`删除多个</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  find</span><br></pre></td></tr></table></figure>，高级查找- `find . -name *lin*`，其中 . 代表在当前目录找，-name 表示匹配文件名 / 文件夹名，*lin* 用通配符搜索含有lin的文件或是文件夹- `find . -iname *lin*`，其中 . 代表在当前目录找，-iname 表示匹配文件名 / 文件夹名（忽略大小写差异），*lin* 用通配符搜索含有lin的文件或是文件夹- `find / -name *.conf`，其中 / 代表根目录查找，*.conf代表搜索后缀会.conf的文件- `find /opt -name .oh-my-zsh`，其中 /opt 代表目录名，.oh-my-zsh 代表搜索的是隐藏文件 / 文件夹名字为 oh-my-zsh 的- `find /opt -type f -iname .oh-my-zsh`，其中 /opt 代表目录名，-type f 代表只找文件，.oh-my-zsh 代表搜索的是隐藏文件名字为 oh-my-zsh 的- `find /opt -type d -iname .oh-my-zsh`，其中 /opt 代表目录名，-type d 代表只找目录，.oh-my-zsh 代表搜索的是隐藏文件夹名字为 oh-my-zsh 的- `find . -name &quot;lin*&quot; -exec ls -l &#123;&#125; \;`，当前目录搜索lin开头的文件，然后用其搜索后的结果集，再执行ls -l的命令（这个命令可变，其他命令也可以），其中 -exec 和 &#123;&#125; ; 都是固定格式- `find /opt -type f -size +800M  -print0 | xargs -0 du -h | sort -nr`，找出 /opt 目录下大于 800 M 的文件- `find / -name &quot;*tower*&quot; -exec rm &#123;&#125; \;`，找到文件并删除- `find / -name &quot;*tower*&quot; -exec mv &#123;&#125; /opt \;`，找到文件并移到 opt 目录- `find . -name &quot;*&quot; |xargs grep &quot;youmeek&quot;`，递归查找当前文件夹下所有文件内容中包含 youmeek 的文件- `find . -size 0 | xargs rm -f &amp;`，删除当前目录下文件大小为0的文件- `du -hm --max-depth=2 | sort -nr | head -12`，找出系统中占用容量最大的前 12 个目录</code></pre></li><li><p><code>cat /etc/resolv.conf</code>，查看 DNS 设置</p></li><li><p><code>netstat -tlunp</code>，查看当前运行的服务，同时可以查看到：运行的程序已使用端口情况</p></li><li><p><code>env</code>，查看所有系统变量</p></li><li><p><code>export</code>，查看所有系统变量</p></li><li><pre><code>echo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - `echo $JAVA_HOME`，查看指定系统变量的值，这里查看的是自己配置的 JAVA_HOME。</span><br><span class="line">  - `echo &quot;字符串内容&quot;`，输出 &quot;字符串内容&quot;</span><br><span class="line">  - `echo &gt; aa.txt`，清空 aa.txt 文件内容（类似的还有：`: &gt; aa.txt`，其中 : 是一个占位符, 不产生任何输出）</span><br><span class="line"></span><br><span class="line">- `unset $JAVA_HOME`，删除指定的环境变量</span><br><span class="line"></span><br><span class="line">- `ln -s /opt/data /opt/logs/data`，表示给 /opt/logs 目录下创建一个名为 data 的软链接，该软链接指向到 /opt/data</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  grep</span><br></pre></td></tr></table></figure>- `shell grep -H &#39;安装&#39; *.sh`，查找当前目录下所有 sh 类型文件中，文件内容包含 `安装` 的当前行内容- `grep &#39;test&#39; java*`，显示当前目录下所有以 java 开头的文件中包含 test 的行- `grep &#39;test&#39; spring.ini docker.sh`，显示当前目录下 spring.ini docker.sh 两个文件中匹配 test 的行</code></pre></li><li><pre><code>ps<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - `ps –ef|grep java`，查看当前系统中有关 java 的所有进程</span><br><span class="line">  - `ps -ef|grep --color java`，高亮显示当前系统中有关 java 的所有进程</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  kill</span><br></pre></td></tr></table></figure>- `kill 1234`，结束 pid 为 1234 的进程- `kill -9 1234`，强制结束 pid 为 1234 的进程（慎重）- `killall java`，结束同一进程组内的所有为 java 进程- `ps -ef|grep hadoop|grep -v grep|cut -c 9-15|xargs kill -9`，结束包含关键字 hadoop 的所有进程</code></pre></li><li><pre><code>head<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - `head -n 10 spring.ini`，查看当前文件的前 10 行内容</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  tail</span><br></pre></td></tr></table></figure>- `tail -n 10 spring.ini`，查看当前文件的后 10 行内容- `tail -200f 文件名`，查看文件被更新的新内容尾 200 行，如果文件还有在新增可以动态查看到（一般用于查看日记文件）</code></pre></li></ul><h2 id="用户、权限-相关命令"><a href="#用户、权限-相关命令" class="headerlink" title="用户、权限-相关命令"></a>用户、权限-相关命令</h2><ul><li><p>使用 pem 证书登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /opt/mykey.pem root@192.168.0.70</span><br></pre></td></tr></table></figure><ul><li>证书权限不能太大，不然无法使用：<code>chmod 600 mykey.pem</code></li></ul></li><li><p><code>hostname</code>，查看当前登陆用户全名</p></li><li><p><code>cat /etc/group</code>，查看所有组</p></li><li><p><code>cat /etc/passwd</code>，查看所有用户</p></li><li><p><code>groups youmeek</code>，查看 youmeek 用户属于哪个组</p></li><li><p><code>useradd youmeek -g judasn</code>，添加用户并绑定到 judasn 组下</p></li><li><pre><code>userdel -r youmeek<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，删除名字为 youmeek 的用户</span><br><span class="line"></span><br><span class="line">  - 参数：`-r`，表示删除用户的时候连同用户的家目录一起删除</span><br><span class="line"></span><br><span class="line">- 修改普通用户 youmeek 的权限跟 root 权限一样：</span><br><span class="line"></span><br><span class="line">  - 常用方法（原理是把该用户加到可以直接使用 sudo 的一个权限状态而已）：</span><br><span class="line"></span><br><span class="line">    - 编辑配置文件：`vim /etc/sudoers`</span><br><span class="line">    - 找到 98 行（预估），有一个：`root    ALL=(ALL)   ALL`，在这一行下面再增加一行，效果如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>   root    ALL=(ALL)   ALL   youmeek    ALL=(ALL)   ALL  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  - 另一种方法：</span><br><span class="line"></span><br><span class="line">    - 编辑系统用户的配置文件：`vim /etc/passwd`，找到 **root** 和 **youmeek** 各自开头的那一行，比如 root 是：`root:x:0:0:root:/root:/bin/zsh`，这个代表的含义为：*用户名:密码:UserId:GroupId:描述:家目录:登录使用的 shell*</span><br><span class="line">    - 通过这两行对比，我们可以直接修改 youmeek 所在行的 UserId 值 和 GroupId 值，都改为 0。</span><br><span class="line"></span><br><span class="line">- `groupadd judasn`，添加一个名为 judasn 的用户组</span><br><span class="line"></span><br><span class="line">- `groupdel judasn`，删除一个名为 judasn 的用户组（前提：先删除组下面的所有用户）</span><br><span class="line"></span><br><span class="line">- `usermod 用户名 -g 组名`，把用户修改到其他组下</span><br><span class="line"></span><br><span class="line">- `passwd youmeek`，修改 youmeek 用户的密码（前提：只有 root 用户才有修改其他用户的权限，其他用户只能修改自己的）</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  chmod 777 文件名/目录</span><br></pre></td></tr></table></figure>，给指定文件增加最高权限，系统中的所有人都可以进行读写。- linux 的权限分为 rwx。r 代表：可读，w 代表：可写，x 代表：可执行- 这三个权限都可以转换成数值表示，r = 4，w = 2，x = 1，- = 0，所以总和是 7，也就是最大权限。第一个 7 是所属主（user）的权限，第二个 7 是所属组（group）的权限，最后一位 7 是非本群组用户（others）的权限。- `chmod -R 777 目录` 表示递归目录下的所有文件夹，都赋予 777 权限- `chown myUsername:myGroupName myFile` 表示修改文件所属用户、组- `chown -R myUsername:myGroupName myFolder` 表示递归修改指定目录下的所有文件权限</code></pre></li><li><pre><code>suchown -R &lt;username&gt; a/chgrp -R &lt;username&gt; a/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ：切换到 root 用户，终端目录还是原来的地方（常用）</span><br><span class="line"></span><br><span class="line">  - `su -`：切换到 root 用户，其中 **-** 号另起一个终端并切换账号</span><br><span class="line">  - `su 用户名`，切换指定用户帐号登陆，终端目录还是原来地方。</span><br><span class="line">  - `su - 用户名`，切换到指定用户帐号登陆，其中 **-** 号另起一个终端并切换账号</span><br><span class="line"></span><br><span class="line">- `exit`，注销当前用户（常用）</span><br><span class="line"></span><br><span class="line">- `sudo 某个命令`，使用管理员权限使用命令，使用 sudo 回车之后需要输入当前登录账号的密码。（常用）</span><br><span class="line"></span><br><span class="line">- `passwd`，修改当前用户密码（常用）</span><br><span class="line"></span><br><span class="line">- 添加临时账号，并指定用户根目录，并只有可读权限方法</span><br><span class="line"></span><br><span class="line">  - 添加账号并指定根目录（用户名 tempuser）：`useradd -d /data/logs -m tempuser`</span><br><span class="line">  - 设置密码：`passwd tempuser` 回车设置密码</span><br><span class="line">  - 删除用户（该用户必须退出 SSH 才能删除成功），也会同时删除组：`userdel tempuser`</span><br><span class="line"></span><br><span class="line">## 磁盘管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  df -h</span><br></pre></td></tr></table></figure>，自动以合适的磁盘容量单位查看磁盘大小和使用空间- `df -k`，以磁盘容量单位 K 为数值结果查看磁盘使用情况- `df -m`，以磁盘容量单位 M 为数值结果查看磁盘使用情况</code></pre></li><li><p><code>du -sh /opt</code>，查看 opt 这个文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）</p></li><li><p><code>du -sh ./*</code>，查看当前目录下所有文件夹大小 （h 的意思 human-readable 用人类可读性较好方式显示，系统会自动调节单位，显示合适大小的单位）</p></li><li><p><code>du -sh /opt/setups/</code>，显示 &#x2F;opt&#x2F;setups&#x2F; 目录所占硬盘空间大小（s 表示 –summarize 仅显示总计，即当前目录的大小。h 表示 –human-readable 以 KB，MB，GB 为单位，提高信息的可读性）</p></li><li><pre><code>mount /dev/sdb5 /newDir/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ，把分区 sdb5 挂载在根目录下的一个名为 newDir 的空目录下，需要注意的是：这个目录最好为空，不然已有的那些文件将看不到，除非卸载挂载。</span><br><span class="line"></span><br><span class="line">  - 挂载好之后，通过：`df -h`，查看挂载情况。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  umount /newDir/</span><br></pre></td></tr></table></figure>，卸载挂载，用目录名- 如果这样卸载不了可以使用：`umount -l /newDir/`</code></pre></li><li><p><code>umount /dev/sdb5</code>，卸载挂载，用分区名</p></li></ul><h2 id="wget-下载文件"><a href="#wget-下载文件" class="headerlink" title="wget 下载文件"></a>wget 下载文件</h2><ul><li>常规下载：<code>wget http://www.gitnavi.com/index.html</code></li><li>自动断点下载：<code>wget -c http://www.gitnavi.com/index.html</code></li><li>后台下载：<code>wget -b http://www.gitnavi.com/index.html</code></li><li>伪装代理名称下载：<code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.gitnavi.com/index.html</code></li><li>限速下载：<code>wget --limit-rate=300k http://www.gitnavi.com/index.html</code></li><li>批量下载：<code>wget -i /opt/download.txt</code>，一个下载地址一行</li><li>后台批量下载：<code>wget -b -c -i /opt/download.txt</code>，一个下载地址一行</li></ul><hr><h1 id="Linux-下常用压缩文件的解压、压缩"><a href="#Linux-下常用压缩文件的解压、压缩" class="headerlink" title="Linux 下常用压缩文件的解压、压缩"></a>Linux 下常用压缩文件的解压、压缩</h1><h2 id="常用压缩包–解压–令整理"><a href="#常用压缩包–解压–令整理" class="headerlink" title="常用压缩包–解压–令整理"></a>常用压缩包–解压–令整理</h2><ul><li><p>Linux 后缀为 <code>.war</code> 格式的文件（一般用在部署 Tomcat 项目的时候）</p></li><li><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -oq XXXXXX.war -d ROOT</span><br></pre></td></tr></table></figure><ul><li>如果没有 ROOT 目录会自动创建 ROOT 目录。</li></ul></li><li><p>Linux 后缀为 <code>.tar.gz</code> 格式的文件-解压</p></li><li><p>命令：<code>tar zxvf XXXXXX.tar.gz</code></p></li><li><p>Linux 后缀为 <code>.bz2</code> 格式的文件-解压</p></li><li><p>命令：<code>bzip2 -d XXXXXX.bz2</code></p></li><li><p>Linux 后缀为 <code>.tar.bz2</code> 格式的文件-解压</p></li><li><p>命令：<code>tar jxvf XXXXXX.tar.bz2</code></p></li><li><p>Linux 后缀为 <code>.tar</code> 格式的文件-解压</p></li><li><p>命令：<code>tar zxvf XXXXXX.tar</code></p></li><li><p>Linux 后缀为 <code>.gz</code> 格式的文件-解压</p></li><li><p>命令：<code>gunzip XXXXXX.gz</code></p></li><li><p>Linux 后缀为 <code>.zip</code> 格式的文件-解压</p></li><li><p>命令：<code>unzip XXXXXX.zip</code></p></li><li><p>命令：<code>unzip XXXXXX.zip -d /opt/</code>，解压到指定目录</p></li><li><p>Linux 后缀为 <code>.7z</code> 格式的文件-解压</p></li><li><p>命令：<code>7za x XXXXXX.7z</code></p></li><li><p>Linux 后缀为 <code>.tar.xz</code> 格式的文件-解压，解压出来是tar，再对tar进行解压</p></li><li><p>命令：<code>tar xf XXXXXX.tar.xz</code></p></li></ul><hr><h2 id="常用文件进行–压缩–命令整理"><a href="#常用文件进行–压缩–命令整理" class="headerlink" title="常用文件进行–压缩–命令整理"></a>常用文件进行–压缩–命令整理</h2><ul><li>Linux 压缩文件夹为后缀 <code>.war</code> 格式的文件（最好不要对根目录进行压缩，不然会多出一级目录）</li><li>命令：<code>jar -cvfM0 cas.war /opt/cas/META-INF /opt/cas/WEB-INF /opt/cas/index.jsp</code></li><li>或者命令：<code>cd 项目根目录 ; jar -cvfM0 cas.war ./*</code></li><li>Linux 压缩文件为后缀 <code>.tar</code> 格式的文件</li><li>命令：<code>tar -zcvf test11.tar test11</code></li><li>Linux 压缩文件为后缀 <code>.tar.gz</code> 格式的文件</li><li>命令：<code>tar -zcvf test11.tar.gz test11</code></li><li>Linux 压缩文件为后缀 <code>.bz2</code> 格式的文件</li><li>命令：<code>bzip2 -v test.txt</code></li><li>Linux 压缩文件为后缀 <code>.tar.bz2</code> 格式的文件</li><li>命令：<code>tar -jcvf test11.tar.gz test11</code></li><li>Linux 压缩文件为后缀 <code>.zip</code> 格式的文件</li><li>命令：<code>zip -r test1.zip /opt/test1/</code></li><li>Linux 压缩文件为后缀 <code>.7z</code> 格式的文件</li><li>命令：<code>7za a test1.7z /opt/test1/</code></li></ul><h2 id="分卷压缩"><a href="#分卷压缩" class="headerlink" title="分卷压缩"></a>分卷压缩</h2><ul><li>分卷压缩：<code>zip -s 100M myFile.zip --out newFile.zip</code></li><li>最终效果：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newFile.z01</span><br><span class="line">newFile.z02</span><br><span class="line">newFile.z03</span><br><span class="line">newFile.z04</span><br><span class="line">newFile.zip</span><br></pre></td></tr></table></figure><h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><ul><li>7z<ul><li>7z 的安装：<ul><li>访问官网下载解压包：<a href="http://sourceforge.net/projects/p7zip/files/p7zip/">http://sourceforge.net/projects/p7zip/files/p7zip/</a></li><li>解压压缩包：<code>tar jxvf p7zip_15.14_src_all.tar.bz2</code></li><li>进入目录：<code>cd p7zip_15.14</code></li><li>执行安装：<code>sh install.sh</code></li></ul></li></ul></li><li>rar<ul><li>rar 的安装：<ul><li>下载：<code>wget http://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz</code></li><li>解压下载下来的压缩包：<code>tar zxvf rarlinux-3.8.0.tar.gz</code></li><li>进入解压后目录：<code>cd rar</code></li><li>编译：<code>make</code></li><li>安装：<code>make install</code></li></ul></li><li>rar 解压：<code>rar x 文件名.rar</code></li></ul></li></ul><hr><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。</p><p>注解</p><p>类似的工具有rsync；scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I&#x2F;O非常高，而scp基本不影响系统正常使用。</p><h2 id="18-1-命令格式："><a href="#18-1-命令格式：" class="headerlink" title="18.1. 命令格式："></a>18.1. 命令格式：</h2><p>scp [参数] [原路径] [目标路径]</p><h2 id="18-2-命令参数："><a href="#18-2-命令参数：" class="headerlink" title="18.2. 命令参数："></a>18.2. 命令参数：</h2><ul><li>-1 强制scp命令使用协议ssh1</li><li>-2 强制scp命令使用协议ssh2</li><li>-4 强制scp命令只使用IPv4寻址</li><li>-6 强制scp命令只使用IPv6寻址</li><li>-B 使用批处理模式（传输过程中不询问传输口令或短语）</li><li>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li><li>-p 留原文件的修改时间，访问时间和访问权限。</li><li>-q 不显示传输进度条。</li><li>-r 递归复制整个目录。</li><li>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li><li>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li><li>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li><li>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li><li>-l limit 限定用户所能使用的带宽，以Kbit&#x2F;s为单位。</li><li>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</li><li>-P port 注意是大写的P, port是指定数据传输用到的端口号</li><li>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li></ul><h2 id="18-3-使用说明"><a href="#18-3-使用说明" class="headerlink" title="18.3. 使用说明"></a>18.3. 使用说明</h2><h3 id="从本地服务器复制到远程服务器"><a href="#从本地服务器复制到远程服务器" class="headerlink" title="从本地服务器复制到远程服务器"></a>从本地服务器复制到远程服务器</h3><p>复制文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$scp local_file remote_username@remote_ip:remote_folder</span><br><span class="line">$scp local_file remote_username@remote_ip:remote_file</span><br><span class="line">$scp local_file remote_ip:remote_folder</span><br><span class="line">$scp local_file remote_ip:remote_file</span><br></pre></td></tr></table></figure><p>指定了用户名，命令执行后需要输入用户密码；如果不指定用户名，命令执行后需要输入用户名和密码；</p><p>复制目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$scp -r local_folder remote_username@remote_ip:remote_folder</span><br><span class="line">$scp -r local_folder remote_ip:remote_folder</span><br></pre></td></tr></table></figure><p>第1个指定了用户名，命令执行后需要输入用户密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><p>注解</p><p>从远程复制到本地的scp命令与上面的命令一样，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p><h2 id="18-4-使用示例"><a href="#18-4-使用示例" class="headerlink" title="18.4. 使用示例"></a>18.4. 使用示例</h2><h3 id="实例1：从远处复制文件到本地目录"><a href="#实例1：从远处复制文件到本地目录" class="headerlink" title="实例1：从远处复制文件到本地目录"></a>实例1：从远处复制文件到本地目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp root@10.6.159.147:/opt/soft/demo.tar /opt/soft/</span><br></pre></td></tr></table></figure><p>说明： 从10.6.159.147机器上的&#x2F;opt&#x2F;soft&#x2F;的目录中下载demo.tar 文件到本地&#x2F;opt&#x2F;soft&#x2F;目录中</p><h3 id="实例2：从远处复制到本地"><a href="#实例2：从远处复制到本地" class="headerlink" title="实例2：从远处复制到本地"></a>实例2：从远处复制到本地</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r root@10.6.159.147:/opt/soft/test /opt/soft/</span><br></pre></td></tr></table></figure><p>说明： 从10.6.159.147机器上的&#x2F;opt&#x2F;soft&#x2F;中下载test目录到本地的&#x2F;opt&#x2F;soft&#x2F;目录来。</p><h3 id="实例3：上传本地文件到远程机器指定目录"><a href="#实例3：上传本地文件到远程机器指定目录" class="headerlink" title="实例3：上传本地文件到远程机器指定目录"></a>实例3：上传本地文件到远程机器指定目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp /opt/soft/demo.tar root@10.6.159.147:/opt/soft/scptest</span><br></pre></td></tr></table></figure><p>说明： 复制本地opt&#x2F;soft&#x2F;目录下的文件demo.tar 到远程机器10.6.159.147的opt&#x2F;soft&#x2F;scptest目录</p><h3 id="实例4：上传本地目录到远程机器指定目录"><a href="#实例4：上传本地目录到远程机器指定目录" class="headerlink" title="实例4：上传本地目录到远程机器指定目录"></a>实例4：上传本地目录到远程机器指定目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r /opt/soft/test root@10.6.159.147:/opt/soft/scptest</span><br></pre></td></tr></table></figure><p>说明： 上传本地目录 &#x2F;opt&#x2F;soft&#x2F;test到远程机器10.6.159.147上&#x2F;opt&#x2F;soft&#x2F;scptest的目录中</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADB 常用命令</title>
      <link href="/blog/2022/04/16/ADB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2022/04/16/ADB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="常用的ADB命令"><a href="#常用的ADB命令" class="headerlink" title="常用的ADB命令"></a>常用的ADB命令</h4><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h5 id="连接USB"><a href="#连接USB" class="headerlink" title="连接USB"></a>连接USB</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb usb</span><br></pre></td></tr></table></figure><h5 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure><h5 id="连接局域网手机"><a href="#连接局域网手机" class="headerlink" title="连接局域网手机"></a>连接局域网手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 192.168.x.x:5555</span><br></pre></td></tr></table></figure><h5 id="断开所有连接"><a href="#断开所有连接" class="headerlink" title="断开所有连接"></a>断开所有连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure><h5 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure><h5 id="查看已连接手机"><a href="#查看已连接手机" class="headerlink" title="查看已连接手机"></a>查看已连接手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><h5 id="断开手机连接"><a href="#断开手机连接" class="headerlink" title="断开手机连接"></a>断开手机连接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb disconnect 192.168.x.x</span><br></pre></td></tr></table></figure><h5 id="指定端口号"><a href="#指定端口号" class="headerlink" title="指定端口号"></a>指定端口号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -p 5555 start-server</span><br></pre></td></tr></table></figure><ul><li>默认为5037</li></ul><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><h5 id="android-系统版本号"><a href="#android-系统版本号" class="headerlink" title="android 系统版本号"></a>android 系统版本号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><h5 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure><h5 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><h5 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><p>更多系统信息:</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>ro.build.version.sdk</td><td>SDK 版本</td></tr><tr><td>ro.build.version.release</td><td>Android 系统版本</td></tr><tr><td>ro.build.version.security_patch</td><td>Android 安全补丁程序级别</td></tr><tr><td>ro.product.model</td><td>型号</td></tr><tr><td>ro.product.brand</td><td>品牌</td></tr><tr><td>ro.product.name</td><td>设备名</td></tr><tr><td>ro.product.board</td><td>处理器型号</td></tr><tr><td>ro.product.cpu.abilist</td><td>CPU 支持的 abi 列表[<em>节注一</em>]</td></tr><tr><td>persist.sys.isUsbOtgEnabled</td><td>是否支持 OTG</td></tr><tr><td>dalvik.vm.heapsize</td><td>每个应用程序的内存上限</td></tr><tr><td>ro.sf.lcd_density</td><td>屏幕密度</td></tr></tbody></table></li></ul><h5 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure><p>  各列含义：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>所属用户</td></tr><tr><td>PID</td><td>进程 ID</td></tr><tr><td>PPID</td><td>父进程 ID</td></tr><tr><td>NAME</td><td>进程名</td></tr></tbody></table><h5 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure><p>  各列含义：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程 ID</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>CPU%</td><td>当前瞬间占用 CPU 百分比</td></tr><tr><td>S</td><td>进程状态（R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）</td></tr><tr><td>#THR</td><td>线程数</td></tr><tr><td>VSS</td><td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td></tr><tr><td>RSS</td><td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td></tr><tr><td>PCY</td><td>调度策略优先级，SP_BACKGROUND&#x2F;SPFOREGROUND</td></tr><tr><td>UID</td><td>进程所有者的用户 ID</td></tr><tr><td>NAME</td><td>进程名</td></tr></tbody></table><h5 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package &lt;pn&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h5 id="指定端口号-1"><a href="#指定端口号-1" class="headerlink" title="指定端口号"></a>指定端口号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -p 5555 start-server</span><br></pre></td></tr></table></figure><ul><li>默认为5037</li></ul><hr><h3 id="查看应用于交互"><a href="#查看应用于交互" class="headerlink" title="查看应用于交互"></a>查看应用于交互</h3><ul><li><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下:</p><ul><li><table><thead><tr><th>command</th><th>用途</th></tr></thead><tbody><tr><td><code>start [options] &lt;INTENT&gt;</code></td><td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td></tr><tr><td><code>startservice [options] &lt;INTENT&gt;</code></td><td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td></tr><tr><td><code>broadcast [options] &lt;INTENT&gt;</code></td><td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td></tr><tr><td><code>force-stop &lt;packagename&gt;</code></td><td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td></tr></tbody></table></li><li><p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p><p>用于决定 intent 对象的选项如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-a &lt;ACTION&gt;</code></td><td>指定 action，比如 <code>android.intent.action.VIEW</code></td></tr><tr><td><code>-c &lt;CATEGORY&gt;</code></td><td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td></tr><tr><td><code>-n &lt;COMPONENT&gt;</code></td><td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td></tr></tbody></table><p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>--esn &lt;EXTRA_KEY&gt;</code></td><td>null 值（只有 key 名）</td></tr><tr><td>&#96;-e</td><td>–es <EXTRA_KEY> <EXTRA_STRING_VALUE>&#96;</td></tr><tr><td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td><td>boolean 值</td></tr><tr><td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td><td>integer 值</td></tr><tr><td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td><td>long 值</td></tr><tr><td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td><td>float 值</td></tr><tr><td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td><td>URI</td></tr><tr><td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td><td>component name</td></tr><tr><td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td><td>integer 数组</td></tr><tr><td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td><td>long 数组</td></tr></tbody></table></li></ul></li></ul><h5 id="查看前台Activity"><a href="#查看前台Activity" class="headerlink" title="查看前台Activity"></a>查看前台Activity</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure><h5 id="安卓App"><a href="#安卓App" class="headerlink" title="安卓App"></a>安卓App</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install</span><br></pre></td></tr></table></figure><p>  后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下:</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-l</td><td>将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td></tr><tr><td>-r</td><td>允许覆盖安装</td></tr><tr><td>-t</td><td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td></tr><tr><td>-s</td><td>将应用安装到 sdcard</td></tr><tr><td>-d</td><td>允许降级覆盖安装</td></tr><tr><td>-g</td><td>授予所有运行时权限</td></tr></tbody></table><h5 id="卸载App"><a href="#卸载App" class="headerlink" title="卸载App"></a>卸载App</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p>  -k为可选参数,表示卸载后保留缓存目录</p><h5 id="截图保存到当前那文件夹"><a href="#截图保存到当前那文件夹" class="headerlink" title="截图保存到当前那文件夹"></a>截图保存到当前那文件夹</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure><h5 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h5><ul><li><p>录制屏幕以 mp4 格式保存到 &#x2F;sdcard：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure><p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p><p>如果需要导出到电脑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure></li></ul><h5 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h5 id="清楚应用缓存"><a href="#清楚应用缓存" class="headerlink" title="清楚应用缓存"></a>清楚应用缓存</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear &lt;pn&gt;</span><br></pre></td></tr></table></figure><h5 id="显示虚拟按键"><a href="#显示虚拟按键" class="headerlink" title="显示虚拟按键"></a>显示虚拟按键</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice -n com.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure><h5 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop &lt;pn&gt;adb reboot</span><br></pre></td></tr></table></figure><hr><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h5 id="复制设备文件到电脑"><a href="#复制设备文件到电脑" class="headerlink" title="复制设备文件到电脑"></a>复制设备文件到电脑</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &lt;设备路径&gt; [电脑目录]</span><br></pre></td></tr></table></figure><ul><li>不设置电脑目录,默认复制到当前文件夹下</li></ul><h5 id="复制电脑文件到手机"><a href="#复制电脑文件到手机" class="headerlink" title="复制电脑文件到手机"></a>复制电脑文件到手机</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push &lt;电脑路径&gt; &lt;设备目录&gt;</span><br></pre></td></tr></table></figure><ul><li>adb push ~&#x2F;sr.mp4 &#x2F;sdcard&#x2F;</li></ul><h3 id="模拟按键-输入"><a href="#模拟按键-输入" class="headerlink" title="模拟按键&#x2F;输入"></a>模拟按键&#x2F;输入</h3><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p><h5 id="模拟按键"><a href="#模拟按键" class="headerlink" title="模拟按键"></a>模拟按键</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent &lt;keycode&gt;</span><br></pre></td></tr></table></figure><p>  - </p><table><thead><tr><th>keycode</th><th>含义</th></tr></thead><tbody><tr><td>3</td><td>HOME 键</td></tr><tr><td>4</td><td>返回键</td></tr><tr><td>5</td><td>打开拨号应用</td></tr><tr><td>6</td><td>挂断电话</td></tr><tr><td>24</td><td>增加音量</td></tr><tr><td>25</td><td>降低音量</td></tr><tr><td>26</td><td>电源键</td></tr><tr><td>27</td><td>拍照（需要在相机应用里）</td></tr><tr><td>64</td><td>打开浏览器</td></tr><tr><td>82</td><td>菜单键</td></tr><tr><td>85</td><td>播放&#x2F;暂停</td></tr><tr><td>86</td><td>停止播放</td></tr><tr><td>87</td><td>播放下一首</td></tr><tr><td>88</td><td>播放上一首</td></tr><tr><td>122</td><td>移动光标到行首或列表顶部</td></tr><tr><td>123</td><td>移动光标到行末或列表底部</td></tr><tr><td>126</td><td>恢复播放</td></tr><tr><td>127</td><td>暂停播放</td></tr><tr><td>164</td><td>静音</td></tr><tr><td>176</td><td>打开系统设置</td></tr><tr><td>187</td><td>切换应用</td></tr><tr><td>207</td><td>打开联系人</td></tr><tr><td>208</td><td>打开日历</td></tr><tr><td>209</td><td>打开音乐</td></tr><tr><td>210</td><td>打开计算器</td></tr><tr><td>220</td><td>降低屏幕亮度</td></tr><tr><td>221</td><td>提高屏幕亮度</td></tr><tr><td>223</td><td>系统休眠</td></tr><tr><td>224</td><td>点亮屏幕</td></tr><tr><td>231</td><td>打开语音助手</td></tr><tr><td>276</td><td>如果没有 wakelock 则让系统休眠</td></tr></tbody></table><h5 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure><p>执行效果相当于按电源键。</p><h5 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure><h5 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure><h5 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h5><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure><h5 id="增加音量："><a href="#增加音量：" class="headerlink" title="增加音量："></a>增加音量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure><h5 id="降低音量："><a href="#降低音量：" class="headerlink" title="降低音量："></a>降低音量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure><h5 id="静音："><a href="#静音：" class="headerlink" title="静音："></a>静音：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure><h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><h5 id="播放-暂停："><a href="#播放-暂停：" class="headerlink" title="播放&#x2F;暂停："></a>播放&#x2F;暂停：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure><h5 id="停止播放："><a href="#停止播放：" class="headerlink" title="停止播放："></a>停止播放：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure><h5 id="播放下一首："><a href="#播放下一首：" class="headerlink" title="播放下一首："></a>播放下一首：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure><h5 id="播放上一首："><a href="#播放上一首：" class="headerlink" title="播放上一首："></a>播放上一首：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure><h5 id="恢复播放："><a href="#恢复播放：" class="headerlink" title="恢复播放："></a>恢复播放：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure><h5 id="暂停播放："><a href="#暂停播放：" class="headerlink" title="暂停播放："></a>暂停播放：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure><h3 id="点亮-熄灭屏幕"><a href="#点亮-熄灭屏幕" class="headerlink" title="点亮&#x2F;熄灭屏幕"></a>点亮&#x2F;熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p><h5 id="点亮屏幕："><a href="#点亮屏幕：" class="headerlink" title="点亮屏幕："></a>点亮屏幕：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure><h5 id="熄灭屏幕："><a href="#熄灭屏幕：" class="headerlink" title="熄灭屏幕："></a>熄灭屏幕：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure><h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p><p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure><p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p><h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure><p>现在 <code>hello</code> 出现在文本框了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 常用命令</title>
      <link href="/blog/2020/08/18/Flutter-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2020/08/18/Flutter-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>查看具体命令帮助信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter help &lt;command&gt;&lt;/command&gt;</span><br></pre></td></tr></table></figure><p>查看flutter SDK所有分支</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter channel</span><br></pre></td></tr></table></figure><p>切换分支（例如切换到stable分支）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter channel stable</span><br></pre></td></tr></table></figure><p>flutter环境诊断</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>查看详细信息</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor -v</span><br></pre></td></tr></table></figure><p>flutter版本升级</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure><p>获取项目所有的依赖包</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><p>获取项目所有依赖包的最新版本</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages upgrade</span><br></pre></td></tr></table></figure><p>添加第三方（例如添加xmpp_plugin）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add xmpp_plugin</span><br></pre></td></tr></table></figure><p>获取第三方包依赖</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub get</span><br></pre></td></tr></table></figure><p>清缓存</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter clean</span><br></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>列出所有连接的设备</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter devices</span><br></pre></td></tr></table></figure><p>运行项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure><p>显示系统日志运行</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run --verbose-system-logs</span><br></pre></td></tr></table></figure><p>指定设备运行项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d &#x27;iPhone Xʀ&#x27;</span><br></pre></td></tr></table></figure><p>运行在所有可用设备上</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d all</span><br></pre></td></tr></table></figure><p>查看可用模拟器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter emulators</span><br></pre></td></tr></table></figure><p>启动iOS模拟器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter emulators --launch apple_ios_simulator</span><br></pre></td></tr></table></figure><p>启动Android 模拟器-只有启动模拟器才可以运行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter emulators --launch Nexus_5X_API_27</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d emulator-5554</span><br></pre></td></tr></table></figure><p>运行IOS真机</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d 00008020-001838491169002E</span><br></pre></td></tr></table></figure><p>查看日志</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter logs</span><br></pre></td></tr></table></figure><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>创建项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create flutter_app</span><br></pre></td></tr></table></figure><p>指定语言：默认Android使用Java，iOS使用Objective-C</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create -i swift -a kotlin flutter_app</span><br></pre></td></tr></table></figure><p>创建混编项目</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create -t module flutter_module</span><br></pre></td></tr></table></figure><p>旧项目新增平台支持</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --platforms=windows,macos,linux .</span><br></pre></td></tr></table></figure><p>开启平台</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-web true</span><br></pre></td></tr></table></figure><p>关闭平台（关闭后可以删除项目中对应的平台目录文件夹）</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --no-enable-web</span><br></pre></td></tr></table></figure><p>开启和关闭平台后都需要使用命令重新构建下项目（最好都关闭项目然后在终端中cd到当前项目目录后执行命令）</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create .</span><br></pre></td></tr></table></figure><p> 如果报错的话用下面这个(上面的旧项目新增平台的命令如果报错也可以试试这个命令)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --org package_name .</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>分析代码</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter analyze</span><br></pre></td></tr></table></figure><p>构建iOS</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build ios</span><br></pre></td></tr></table></figure><p>安卓打包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk</span><br></pre></td></tr></table></figure><p>iOS打包，运行命令后在xcode中打包</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build ios --release</span><br></pre></td></tr></table></figure><p>打包web，文件在build目录下</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build web</span><br></pre></td></tr></table></figure><p>截图</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter screenshot</span><br></pre></td></tr></table></figure><p>清除插件缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub cache repair</span><br></pre></td></tr></table></figure><p>创建插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --org com.example --template=plugin --platforms=android,ios,linux,macos,windows -a kotlin project-name</span><br></pre></td></tr></table></figure><p>安卓打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#arm64</span><br><span class="line">flutter build apk --release --split-per-abi --build-number=1 --build-name=wuhope --tree-shake-icons --analyze-size --target-platform=android-arm64</span><br><span class="line"></span><br><span class="line">#x86</span><br><span class="line">flutter build apk --release --split-per-abi --build-number=1 --build-name=wuhope --tree-shake-icons --analyze-size --target-platform=android-x64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令</title>
      <link href="/blog/2018/11/18/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2018/11/18/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常用的Git操作命令</p></blockquote><ul><li><a href="#%E5%AE%89%E8%A3%85git">安装Git</a></li><li>配置文件<ul><li><a href="#%E6%9F%A5%E7%9C%8Bconfig">查看config</a></li><li><a href="#%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">设置用户信息</a></li><li><a href="#git%E5%88%AB%E5%90%8D">Git别名</a></li><li><a href="#gitignore%E6%96%87%E4%BB%B6">.gitignore文件</a></li></ul></li><li>仓库的基础操作<ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%93%E5%BA%93">初始化仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA">添加文件到暂存区</a></li><li><a href="#status%E4%BB%93%E5%BA%93">status仓库</a></li><li><a href="#diff%E4%BB%93%E5%BA%93">diff仓库</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0">提交更新</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6">移除文件</a></li><li><a href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6">移动文件</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4">查看历史提交</a></li><li><a href="#%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C">撤销操作</a></li><li><a href="#%E6%A0%87%E7%AD%BE">标签</a></li></ul></li><li>分支操作<ul><li><a href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%88%9B%E5%BB%BA">分支的创建</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%88%87%E6%8D%A2">分支的切换</a></li><li><a href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6">分支合并</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF">删除分支</a></li><li><a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">分支管理</a></li><li><a href="#%E5%8F%98%E5%9F%BA">变基</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">远程分支</a></li><li><a href="#%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF">跟踪分支</a></li></ul></li><li>远程仓库操作<ul><li><a href="#%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93">克隆仓库</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">查看远程仓库</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">添加远程仓库</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%8B%89%E5%8F%96%E6%8E%A8%E9%80%81">远程仓库的拉取推送</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%A7%BB%E9%99%A4%E9%87%8D%E5%91%BD%E5%90%8D">远程仓库移除重命名</a></li></ul></li></ul><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><strong>Linux</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p><strong>Mac</strong></p><p>直接在<code>Terminal</code>执行<code>git</code>命令, 如果没有会提示安装方法.</p><p>如果喜欢安装程序的话, <a href="http://git-scm.com/download/mac">点这里</a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>第一次安装, 千万别要忘了配置你的git的使用者名字和邮箱. 这个道理很简单, 每一次的提交时需要记录提交者的, 如果没有提交者, 那么bug出现找谁来背锅??</p><h3 id="查看config"><a href="#查看config" class="headerlink" title="查看config"></a>查看config</h3><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。</p><p><strong><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --system --list</span><br></pre></td></tr></table></figure><hr><p><strong><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --list</span><br></pre></td></tr></table></figure><hr><p>当前使用仓库的 Git 目录中的 config 文件（就是 <code>.git/config</code>）：针对该仓库。</p><p>每一个级别覆盖上一级别的配置，所以<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。</p><hr><p><strong>当然, 也可以查看某一项配置信息.</strong></p><ul><li>形式:<code>git config [--global|--system] &lt;key&gt;</code></li></ul><p><em>查看最终的配置属性值</em> <code>$ git config user.name</code></p><p><em>查看当前系统的属性值</em> <code>$ git config --global user.name</code></p><hr><h3 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;name&quot;</span><br><span class="line">$ git config --global user.email xxx@163.com</span><br></pre></td></tr></table></figure><p>使用<code>--global</code>选项, 当以后在该系统上做的任何操作都会使用此属性. 如果你需要在某一个特定的项目使用其他名字和邮箱, 那么可以通过设置<strong>项目中的config文件</strong>, 这样config中的属性会覆盖掉<strong>global的全局属性</strong>, 并且当在其他项目中并不会造成影响. 使用方式只需要去掉<code>--global</code>参数即可修改项目中的<code>.git/config</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name &quot;name&quot;</span><br></pre></td></tr></table></figure><hr><p><strong>获取帮助手册</strong></p><p>形式: <code>git help &lt;verb&gt;</code> 或者 <code>git &lt;verb&gt; --help</code></p><p>比如查看config手册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git help config</span><br></pre></td></tr></table></figure><h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>例如: 生成别名之后可以在日后用简短的表示来使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>对于自动生成的文件, 日志, 编译的临时文件等. 可以对其进行配置, 让git不追踪这些文件</p><p>规范如下:</p><ul><li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（&#x2F;）开头防止递归。</li><li>匹配模式可以以（&#x2F;）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反</li></ul><p><code>glob模式</code>是指shell所使用的简化了的正则表达式.</p><ul><li><code>*</code> :匹配零个或多个任意字符</li><li><code>[abc]</code> :只匹配括号内的任意一个字符</li><li><code>[0-9]</code> :使用短划线表示范围, 可以匹配0到9之间的任何字符.</li><li><code>?</code> :匹配任意一个字符</li><li><code>**</code>:匹配任意的中间目录,例如<code>a/**/z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>等</li></ul><p>如下给出一个样板:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有以 .c结尾的文件</span><br><span class="line">*.c</span><br><span class="line"></span><br><span class="line"># 但是 stream.c 会被git追踪</span><br><span class="line">!stream.c</span><br><span class="line"></span><br><span class="line"># 只忽略当前文件夹下的TODO文件, 不包括其他文件夹下的TODO例如: subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># 忽略所有在build文件夹下的文件</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略 doc/notes.txt, 但不包括多层下.txt例如: doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># 忽略所有在doc目录下的.pdf文件</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><h2 id="仓库的基础操作"><a href="#仓库的基础操作" class="headerlink" title="仓库的基础操作"></a>仓库的基础操作</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加全部暂存区和历史区不存在的或者有更改的 `.c`结尾的文件</span><br><span class="line">$ git add *.c</span><br><span class="line"></span><br><span class="line"># 添加全部暂存区和历史区不存在的或者有更改的文件</span><br><span class="line">$ git add .  </span><br><span class="line"></span><br><span class="line"># 指定文件添加</span><br><span class="line">$ git add test.c</span><br></pre></td></tr></table></figure><hr><h3 id="status仓库"><a href="#status仓库" class="headerlink" title="status仓库"></a>status仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 如果需要显示一种紧凑式格式</span><br><span class="line">$ git status --short      # 等价于 $ git status -s</span><br></pre></td></tr></table></figure><p>紧凑式中字母的表示含义如下:</p><ul><li><code>??</code> :表示新添加的未追踪的文件</li><li><code> M</code> :M出现在右边,表示该文件被修改但是还没有放入暂存区</li><li><code>M </code> :M出现在左边,表示文件被修改已经放入了暂存区</li><li><code>MM</code> :出现两个,代表此文件在工作区修改已经放入了暂存区, 但之后有进行了修改,没有添加到暂存区</li></ul><hr><h3 id="diff仓库"><a href="#diff仓库" class="headerlink" title="diff仓库"></a>diff仓库</h3><p>如果你想知道文件具体修改的内容, 那么<code>diff</code>会很有用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看以追踪但尚未暂存的文件更新了哪些部分, 不添加额外参数</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 对使用了add添加到了暂存区的内容, 使用--staged参数或者--cached</span><br><span class="line">$ git diff --staged</span><br></pre></td></tr></table></figure><h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 常规做法</span><br><span class="line">$ git commit -m &quot;commit message&quot;</span><br><span class="line"></span><br><span class="line"># 如果不使用-m参数添加提交信息, git会使用默认的编译器如vi进行提交描述编写.</span><br><span class="line"># 可通过$ git config --global core.edit 设定喜欢的编译器</span><br><span class="line"></span><br><span class="line"># 跳过暂存区操作, 直接从工作区提交到历史区</span><br><span class="line">$ git commit -a -m &quot;&quot;          #等价于: $ git commit -am &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>如果在工作区间对一个文件进行删除, 需要先进行<code>add</code>,然后才可以提交. 使用<code>git rm</code>可以直接在工作区间删除文件, 并提交到暂存区.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rm fileName</span><br><span class="line"></span><br><span class="line"># 如果文件修改,并添加了暂存区, 需要使用-f参数来强制删除(force)</span><br><span class="line">$ git rm -f fileName</span><br><span class="line"></span><br><span class="line"># 可以使用glob模式,如下</span><br><span class="line">$ git rm log/\*.log         # 删除log目录下所有名称是.log结尾文件</span><br><span class="line">$ git rm \*~                # 删除以~结尾的所有文件</span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>同样使用<code>git rm</code>会方便很多, 并且如果相对文件重命名也可以如此</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure><p>当执行了这条语句之后, 只需要在下一次<code>commit</code>即可, 不需要考虑额外操作. 等价于如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv file_from file_to</span><br><span class="line">$ git rm file_from</span><br><span class="line">$ git rm file_to</span><br></pre></td></tr></table></figure><h3 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h3><p>如果是最基本的<code>git log</code>, 那么会按提交时间列出所有更新, 包括提交的SHA-1校验和, 作者名称,邮箱,提交时间,提交说明. 下面说说常用选项.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -p:仅显示最近x次的提交  格式 $ git log -p -x</span><br><span class="line">$ git log -p -2             # 查看最近的两次提交内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># --stat:简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># --pretty: 指定默认不同格式展示信息</span><br><span class="line">$ git log --pretty=oneline              #每次提交用一行显示</span><br><span class="line"></span><br><span class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;  </span><br><span class="line"># 效果:1a99c42 - 苏, 19 hours ago : 无意义提交</span><br></pre></td></tr></table></figure><p><strong>关于<code>format</code>对应的常用占位符的写法和意义</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交对象（commit）的完整哈希字串</td></tr><tr><td>%h</td><td>提交对象的简短哈希字串</td></tr><tr><td>%T</td><td>树对象（tree）的完整哈希字串</td></tr><tr><td>%t</td><td>树对象的简短哈希字串</td></tr><tr><td>%P</td><td>父对象（parent）的完整哈希字串</td></tr><tr><td>%p</td><td>父对象的简短哈希字串</td></tr><tr><td>%an</td><td>作者（author）的名字</td></tr><tr><td>%ae</td><td>作者的电子邮件地址</td></tr><tr><td>%ad</td><td>作者修订日期（可以用 –date&#x3D; 选项定制格式）</td></tr><tr><td>%ar</td><td>作者修订日期，按多久以前的方式显示</td></tr><tr><td>%cn</td><td>提交者(committer)的名字</td></tr><tr><td>%ce</td><td>提交者的电子邮件地址</td></tr><tr><td>%cd</td><td>提交日期</td></tr><tr><td>%cr</td><td>提交日期，按多久以前的方式显示</td></tr><tr><td>%s</td><td>提交说明</td></tr></tbody></table><hr><p><strong>图形展示分支的合并历史</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --oneline   #oneline只是让输出看起来比较舒服</span><br></pre></td></tr></table></figure><hr><p><strong>git log的一些其他操作</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td>–stat</td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td>–name-only</td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td>–name-status</td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td>–abbrev-commit</td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td>–relative-date</td><td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td>–graph</td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td>–pretty</td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><p><strong>查找一个字符串的出现和删除的提交</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用限制符-S后面紧跟要查询的字符串</span><br><span class="line">$ git log -Smethod_name</span><br><span class="line"></span><br><span class="line"># 或者针对一个文件进行更改的提交查询, 只需要在后面追加文件名称即可</span><br><span class="line">$ git log fileName</span><br></pre></td></tr></table></figure><p>哈哈,即使如果你不小心写个隐藏bug不管几个月之后,如果老大要想找出问题是写引发的其实很简单.例如这样 <code>$ git log -p fileName</code> 想甩锅?算了吧,还是认错以后多注意吧.</p><p><strong>还有一些限制log输出的选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-(n)</td><td>仅显示最近的 n 条提交</td></tr><tr><td>–since, –after</td><td>仅显示指定时间之后的提交。</td></tr><tr><td>–until, –before</td><td>仅显示指定时间之前的提交。</td></tr><tr><td>–author</td><td>仅显示指定作者相关的提交。</td></tr><tr><td>–committer</td><td>仅显示指定提交者相关的提交。</td></tr><tr><td>–grep</td><td>仅显示含指定关键字的提交</td></tr><tr><td>-S</td><td>仅显示添加或移除了某个关键字的提交</td></tr></tbody></table><p>一个实际的例子，如果要查看 Git 仓库中，2016 年 11 月1号到7号，作者叫苏的提交文件，可以用下面的查询命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&quot;%h - %s&quot; --author=苏 --since=&quot;2016-11-01&quot; \</span><br><span class="line">   --before=&quot;2016-11-07&quot;</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>amend重新提交</strong></p><p>当我们<code>commit</code>之后突然发现漏掉了一个文件, 这个时候不可能对一个文件再进行<code>commit</code>一次, 这样做就显得很多余, 而如果版本回退之前再添加也比较麻烦. 这个时候就可以使用这个<code>amend</code>命令.如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;版本1.5开发代码&quot;</span><br><span class="line"></span><br><span class="line"># 正当你松了一口气的时候发现配置文件忘记修改了, 你赶紧修改,并适合用add到暂存区</span><br><span class="line">$ git add project.property</span><br><span class="line">$ git commit --amend         </span><br><span class="line"># 你会神奇的发现你没有增加任何多余的操作就把漏掉的文件补齐到最后一次提交中</span><br></pre></td></tr></table></figure><hr><p><strong>取消暂存的文件</strong></p><p>就是对文件进行了<code>git add</code>操作. 这个时候可以<code>reset</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 让暂存区的文件变成文件修改但是没有添加暂存区的状态</span><br><span class="line">$ git reset HEAD fileName</span><br></pre></td></tr></table></figure><p><strong>撤销对文件的修改</strong></p><p>场景: 当文件修改了, 但是还没有进行<code>git add</code>的时候还只是在工作区间, 还原成最后一次提交的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- filename</span><br></pre></td></tr></table></figure><p>要注意使用, 使用之前确定是否要抛弃已经添加的内容. 因为这个动作可能让你最新添加的内容彻底丢失. 因为没有进行<code>commit</code>, 一般来说进行了<code>commit</code>的内容都是可以恢复的.</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote><p>Git可以给历史中的某一个提交打上标签, 以示重要. 比如每次正式版本的上线等.</p></blockquote><p><strong>列出标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 如果你只关心某一部分的标签, 例如只对v2.x的标签感兴趣,你可以这样做</span><br><span class="line">$ git tag -l &#x27;v2.*&#x27;</span><br></pre></td></tr></table></figure><hr><p><strong>创建标签</strong></p><p>标签分为两种一种是<code>附加标签</code>另一种是<code>轻量标签</code>.</p><ul><li>附加标签: 会保存打标签者的信息, 时间和附加信息. 最后更随打标签的提交</li><li>轻量标签: 只是在一个提交上做一个标记. 存储在一个专门保存标签的文件,指向提交的hash值</li></ul><p>先来看附加标签:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 -m &#x27;附加信息&#x27;</span><br></pre></td></tr></table></figure><p>轻量标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>后期打标签, 就是对已经提交某次提交进行追加标签设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以先使用git log --oneline获取提交历史的hash值</span><br><span class="line">$ git log --oneline</span><br><span class="line"></span><br><span class="line"># 然后把hash值赋值到标签语句之后</span><br><span class="line">$ git tag -a v1.1 a6b4c97</span><br></pre></td></tr></table></figure><p><strong>共享标签</strong></p><p>默认情况下, <code>git push</code>不会把标签传递到远程服务器. 需要显示的推送标签共享到服务器 例如: <code>git push origin [tagname]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.4</span><br><span class="line"></span><br><span class="line"># 如果想把本地上所有在远程服务器上的不存在标签删除掉,可以这样</span><br><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><hr><p><strong>检出标签</strong></p><p>git中不能真正的检出一个标签, 但是可以在标签处创建一个新的分支.如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b checkbranch2 v2.0</span><br></pre></td></tr></table></figure><hr><p><strong>查看标签对应的信息</strong></p><p>使用<code>git show &lt;标签名&gt;</code>可以查看对应标签的详细信息, 如果<code>git show</code>这样的命令只是显示上次提交的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h3><p>分支的创建, 其实本质就是创建一个可以移动的指针,这个指针名就是新的分支名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line"></span><br><span class="line"># 上面的只是创建了一个分支. 并没有切换, 可以使用一条命令创建并且换到新分支</span><br><span class="line">$ git checkout -b dev</span><br><span class="line"></span><br><span class="line"># 可以通过`git log`命令查看各个分支所指向的对象</span><br><span class="line">$ git log --oneline --decorate</span><br><span class="line"></span><br><span class="line"># 如果你想查看图形式的分叉历史,可以这样:</span><br><span class="line">$ git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure><h3 id="分支的切换"><a href="#分支的切换" class="headerlink" title="分支的切换"></a>分支的切换</h3><p>所谓的分支切换就是<code>HEAD</code>指针的指向的改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>利用<code>git merge &lt;要合并到的目标分支&gt;</code>, 这条命令会把当前所在分支与目标分支的内容合并, 可以这样理解, 如果当你试图向目标分支合并时, 如果当前分支可以顺着一个分支走下去, 那么本质上其实只是当前指针的向前移动, 由于这种情况下的合并并没有需要解决的分期, 所以git会称这个是<code>fast-forward</code>快速前进.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个功能分支开发完毕之后, 并进行了合并, 通常这个分支也就被删除,以保证仓库中的干净.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除dev分支</span><br><span class="line">$ git branch -d dev</span><br><span class="line"></span><br><span class="line"># 如果dev分支还有未提交的内容,为了保证你的数据安全git默认是不允许删除,可以使用`-D`强制删除</span><br><span class="line">$ git branch -D dev</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><code>git branch</code>命令不只是可以创建于删除分支. 如果不添加任何参数, 那么会得到所有分支的一个列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch        # 其中一个分支前面的*代表,目前检出的分支就是HEAD指针所指向的分支</span><br><span class="line"></span><br><span class="line"># 追加-v参数 可以展示每一个分支最后一次提交</span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"># --merged:查看那些分支已经合并到当前分支</span><br><span class="line">$ git branch --merged        # 一般这个列表展示的除了*号的其他分支, 都可以删除</span><br><span class="line"></span><br><span class="line"># --no-merged:查看所有包含未合并工作的分支</span><br><span class="line">$ git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><blockquote><p>和合并<code>merge</code>相似的效果都是合并分支, 但是使用变基<code>rebase</code>可以让提交历史变得更简洁. 如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># rebase &lt;目标分支名&gt; [需要移动变基底的分支]</span><br><span class="line">$ git rebase master experiment</span><br><span class="line"></span><br><span class="line"># 此时目标分支后面会追加另一个分支的提交. 此时只需要切换到master分支,合并分支即可.</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge experiment</span><br></pre></td></tr></table></figure><p><code>rebase</code>原理就是, 从目标分支和要变基的分支向上查找出共同祖先节点就是<code>c2</code>, 然后把要变基的分支到<code>c2</code>节点的所有提交,提取出相应的修改生成一个副本, 并追加到目标分创建相对应的提交. 此时变基的分支指向<code>目标分支master</code>的后面某一次提交. 此时只要使用修改<code>master</code>指向指针使用<code>merge</code>即可.</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获得远程的仓库列表</span><br><span class="line">$ git ls-remote origin</span><br><span class="line"></span><br><span class="line"># 如果想获得更多的信息</span><br><span class="line">$ git remote show origin</span><br><span class="line"></span><br><span class="line"># 查看远程分支和本地分支</span><br><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure><hr><p><strong>拉取远程分支</strong></p><p>假设远程如果有一个<code>dev</code>分支, 你使用<code>fetch</code>进行抓取. 这个时候, 本地不会自动生成一个可编辑的副本, 换句话说就是这种情况下, 不会有一个新的<code>dev</code>本地分支, 只有一个不可以修改的<code>origin/dev</code>指针. 这个时候可以运行<code>git merge origin/dev</code>命令, 将这些远程dev分支的工作合并到当前分支. 如果想要在自己本地的dev分支上工作, 可以将其建立在远程分支之上.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><hr><p><strong>创建远程分支</strong></p><p>如果你的本地有一个新建的<code>dev</code>分支, 并且你进行了提交, 此时你想把这个分支也提交到远程的<code>dev</code>分支, 但是远程还没有创建<code>dev</code>, 这个时候可以使用如下命令: <code>git push &lt;远程仓库名&gt; &lt;要推送的本地分支&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><hr><p><strong>删除远程分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除远程dev分支</span><br><span class="line">$ git push origin --delete dev</span><br></pre></td></tr></table></figure><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 <code>跟踪分支</code>（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入<code> git pull</code>，<code>Git</code> 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 <code>master</code> 分支。 最简单的就是之前看到的例子，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/dev</span><br><span class="line"></span><br><span class="line"># 如果想要自定义本地分支名字</span><br><span class="line">$ git checkout -b 任意分支名字 origin/dev</span><br></pre></td></tr></table></figure><hr><p><strong>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支</strong>，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置HEAD指向的分支的上游为远程dev分支</span><br><span class="line">$ git branch -u origin/dev</span><br></pre></td></tr></table></figure><hr><p><strong>查看设置的所有跟踪分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br></pre></td></tr></table></figure><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &lt;url&gt;</span><br><span class="line"></span><br><span class="line"># 如果你想创建自己的仓库名, 就是本地根文件夹的名称, 那么可以如下追加名称</span><br><span class="line">$ git clone &lt;url&gt; [dirName]</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认查看远程仓库的方式</span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"># 查看远程仓库的读写权限. 如果可以看到(push)说明提交的推送</span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>如果需要查看某一个仓库更多的信息时, 使用<code>git remote show ...</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 格式: git remote add [shortName] &lt;url&gt;  同时可以指定一个仓库的引用名称,例如</span><br><span class="line">$ git remote add rp git@github.com:suzeyu1992/GitOperateDemo.git</span><br><span class="line"></span><br><span class="line"># 此时你想对新加的远程进行拉取动作, 只需要使用之前的引用名称就可以</span><br><span class="line">$ git fetch rp</span><br></pre></td></tr></table></figure><h3 id="远程仓库的拉取推送"><a href="#远程仓库的拉取推送" class="headerlink" title="远程仓库的拉取推送"></a>远程仓库的拉取推送</h3><p><strong>拉取</strong></p><p>大家常用的可能是<code>git pull</code>这个指令. 这个指令的通常会从服务器上抓取数据自动尝试合并到当前所在分支.</p><p>而我们可以也可以利用<code>git fetch </code>进行本地分支所追踪的远程分支没有提交. 然后我们可以手动的进行合并.</p><p><strong>推送</strong></p><p><code>git push [remote-name] [branch-name]</code> 例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当对服务器有写入权限, 并且之前没有人提交, 这条命令才会生效.</p><p>上面的这两个推送也好拉取也好. 如果所在分支设置了远程服务器分支的追踪, 那么可以省略掉后面的仓库名和分支名. 如果没有设置那么必须显示的指定.</p><h3 id="远程仓库移除重命名"><a href="#远程仓库移除重命名" class="headerlink" title="远程仓库移除重命名"></a>远程仓库移除重命名</h3><p>对远程仓库的名称进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename oldName newName</span><br></pre></td></tr></table></figure><p>想要移除一个远程仓库,例如服务器搬走了,不再使用一个特定镜像,或者一个贡献者不再贡献</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm 仓库名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
